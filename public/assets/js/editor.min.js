(() => {
	'use strict'; var e = { "class": "className", contenteditable: "contentEditable", "for": "htmlFor", readonly: "readOnly", maxlength: "maxLength", tabindex: "tabIndex", colspan: "colSpan", rowspan: "rowSpan", usemap: "useMap" }; function g(a, b) { try { return a(b) } catch (c) { return b } }
	var m = document, n = window, aa = m.documentElement, p = m.createElement.bind(m), r = Array.isArray, t = Array.prototype, ba = t.concat, u = t.filter, v = t.indexOf, w = t.map, ca = t.push, y = t.slice, A = t.some, da = t.splice, ea = /^#(?:[\w-]|\\.|[^\x00-\xa0])*$/, fa = /^\.(?:[\w-]|\\.|[^\x00-\xa0])*$/, ha = /<.+>/, ia = /^\w+$/; function B(a, b) { return a && (C(b) || D(b)) ? fa.test(a) ? b.getElementsByClassName(a.slice(1)) : ia.test(a) ? b.getElementsByTagName(a) : b.querySelectorAll(a) : [] }
	var E = function () { function a(a, c) { if (a) { if (a instanceof E) return a; var b = a; if (F(a)) { if (b = (c instanceof E ? c[0] : c) || m, b = ea.test(a) ? b.getElementById(a.slice(1)) : ha.test(a) ? G(a) : B(a, b), !b) return } else if (H(a)) return this.ready(a); if (b.nodeType || b === n) b = [b]; this.length = b.length; a = 0; for (c = this.length; a < c; a++)this[a] = b[a] } } a.prototype.init = function (b, c) { return new a(b, c) }; return a }(), I = E.prototype, J = I.init; J.fn = J.prototype = I; I.length = 0; I.splice = da; "function" === typeof Symbol && (I[Symbol.iterator] = t[Symbol.iterator]);
	I.map = function (a) { return J(ba.apply([], w.call(this, function (b, c) { return a.call(b, c, b) }))) }; I.slice = function (a, b) { return J(y.call(this, a, b)) }; var ja = /-([a-z])/g; function K(a) { return a.replace(ja, function (a, c) { return c.toUpperCase() }) } function L(a, b, c) { if (c) for (c = a.length; c-- && !1 !== b.call(a[c], c, a[c]);); else { c = 0; for (var d = a.length; c < d && !1 !== b.call(a[c], c, a[c]); c++); } return a } J.each = L; I.each = function (a) { return L(this, a) }; I.removeProp = function (a) { return this.each(function (b, c) { delete c[e[a] || a] }) };
	J.guid = 1; function ka(a, b) { var c = a && (a.matches || a.webkitMatchesSelector || a.msMatchesSelector); return !!c && !!b && c.call(a, b) } function M(a) { return !!a && a === a.window } function C(a) { return !!a && 9 === a.nodeType } function D(a) { return !!a && 1 === a.nodeType } function H(a) { return "function" === typeof a } function F(a) { return "string" === typeof a } function la(a) { return !isNaN(parseFloat(a)) && isFinite(a) } J.isWindow = M; J.isFunction = H; J.isNumeric = la; J.isArray = r;
	I.prop = function (a, b) { if (a) { if (F(a)) return a = e[a] || a, 2 > arguments.length ? this[0] && this[0][a] : this.each(function (c, h) { h[a] = b }); for (var c in a) this.prop(c, a[c]); return this } }; I.get = function (a) { if (void 0 === a) return y.call(this); a = Number(a); return this[0 > a ? a + this.length : a] }; I.eq = function (a) { return J(this.get(a)) }; I.first = function () { return this.eq(0) }; I.last = function () { return this.eq(-1) };
	function N(a) { return F(a) ? function (b, c) { return ka(c, a) } : H(a) ? a : a instanceof E ? function (b, c) { return a.is(c) } : a ? function (b, c) { return c === a } : function () { return !1 } } I.filter = function (a) { var b = N(a); return J(u.call(this, function (a, d) { return b.call(a, d, a) })) }; function O(a, b) { return b ? a.filter(b) : a } var ma = /\S+/g; function P(a) { return F(a) ? a.match(ma) || [] : [] } I.hasClass = function (a) { return !!a && A.call(this, function (b) { return D(b) && b.classList.contains(a) }) };
	I.removeAttr = function (a) { var b = P(a); return this.each(function (a, d) { D(d) && L(b, function (a, b) { d.removeAttribute(b) }) }) }; I.attr = function (a, b) { if (a) { if (F(a)) { if (2 > arguments.length) { if (!this[0] || !D(this[0])) return; var c = this[0].getAttribute(a); return null === c ? void 0 : c } return void 0 === b ? this : null === b ? this.removeAttr(a) : this.each(function (c, h) { D(h) && h.setAttribute(a, b) }) } for (c in a) this.attr(c, a[c]); return this } };
	I.toggleClass = function (a, b) { var c = P(a), d = void 0 !== b; return this.each(function (a, f) { D(f) && L(c, function (a, c) { d ? b ? f.classList.add(c) : f.classList.remove(c) : f.classList.toggle(c) }) }) }; I.addClass = function (a) { return this.toggleClass(a, !0) }; I.removeClass = function (a) { return arguments.length ? this.toggleClass(a, !1) : this.attr("class", "") };
	function Q(a, b, c, d) { for (var h = [], f = H(b), l = d && N(d), x = 0, k = a.length; x < k; x++)if (f) { var q = b(a[x]); q.length && ca.apply(h, q) } else for (q = a[x][b]; !(null == q || d && l(-1, q));)h.push(q), q = c ? q[b] : null; return h } function R(a) { return 1 < a.length ? u.call(a, function (a, c, d) { return v.call(d, a) === c }) : a } J.unique = R; I.add = function (a, b) { return J(R(this.get().concat(J(a, b).get()))) }; function S(a, b, c) { if (D(a)) { var d = n.getComputedStyle(a, null); return c ? d.getPropertyValue(b) || void 0 : d[b] || a.style[b] } }
	function T(a, b) { return parseInt(S(a, b), 10) || 0 } var na = /^--/, oa = { opacity: !0, order: !0, zIndex: !0 }; function pa(a, b, c) { void 0 === c && (c = na.test(a)); return c || oa[a] || !la(b) ? b : b + "px" } I.css = function (a, b) { if (F(a)) { var c = na.test(a); if (2 > arguments.length) return this[0] && S(this[0], a, c); if (!a) return this; b = pa(a, b, c); return this.each(function (d, f) { D(f) && (c ? f.style.setProperty(a, b) : f.style[a] = b) }) } for (var d in a) this.css(d, a[d]); return this }; var qa = /^\s+|\s+$/;
	function ra(a, b) { a = a.dataset[b] || a.dataset[K(b)]; return qa.test(a) ? a : g(JSON.parse, a) } I.data = function (a, b) { if (!a) { if (!this[0]) return; var c = {}, d; for (d in this[0].dataset) c[d] = ra(this[0], d); return c } if (F(a)) return 2 > arguments.length ? this[0] && ra(this[0], a) : void 0 === b ? this : this.each(function (c, d) { c = b; c = F(c) ? c : g(JSON.stringify, c); d.dataset[K(a)] = c }); for (d in a) this.data(d, a[d]); return this };
	function sa(a, b) { var c = a.documentElement; return Math.max(a.body["scroll" + b], c["scroll" + b], a.body["offset" + b], c["offset" + b], c["client" + b]) } function ta(a, b) { return T(a, "border" + (b ? "Left" : "Top") + "Width") + T(a, "padding" + (b ? "Left" : "Top")) + T(a, "padding" + (b ? "Right" : "Bottom")) + T(a, "border" + (b ? "Right" : "Bottom") + "Width") }
	L([!0, !1], function (a, b) { L(["Width", "Height"], function (a, d) { I[(b ? "outer" : "inner") + d] = function (c) { if (this[0]) return M(this[0]) ? b ? this[0]["inner" + d] : this[0].document.documentElement["client" + d] : C(this[0]) ? sa(this[0], d) : this[0][(b ? "offset" : "client") + d] + (c && b ? T(this[0], "margin" + (a ? "Top" : "Left")) + T(this[0], "margin" + (a ? "Bottom" : "Right")) : 0) } }) });
	L(["Width", "Height"], function (a, b) { var c = b.toLowerCase(); I[c] = function (d) { if (!this[0]) return void 0 === d ? void 0 : this; if (!arguments.length) return M(this[0]) ? this[0].document.documentElement["client" + b] : C(this[0]) ? sa(this[0], b) : this[0].getBoundingClientRect()[c] - ta(this[0], !a); var h = parseInt(d, 10); return this.each(function (b, d) { D(d) && (b = S(d, "boxSizing"), d.style[c] = pa(c, h + ("border-box" === b ? ta(d, !a) : 0))) }) } }); var U = {};
	I.toggle = function (a) { return this.each(function (b, c) { if (D(c)) if (void 0 === a ? "none" === S(c, "display") : a) { if (c.style.display = c.___cd || "", "none" === S(c, "display")) { b = c.style; c = c.tagName; if (U[c]) c = U[c]; else { var d = p(c); m.body.insertBefore(d, null); var h = S(d, "display"); m.body.removeChild(d); c = U[c] = "none" !== h ? h : "block" } b.display = c } } else c.___cd = S(c, "display"), c.style.display = "none" }) }; I.hide = function () { return this.toggle(!1) }; I.show = function () { return this.toggle(!0) };
	function ua(a, b) { return !b || !A.call(b, function (b) { return 0 > a.indexOf(b) }) } var V = { focus: "focusin", blur: "focusout" }, W = { mouseenter: "mouseover", mouseleave: "mouseout" }, va = /^(mouse|pointer|contextmenu|drag|drop|click|dblclick)/i; function wa(a, b, c, d, h) { var f = a.___ce = a.___ce || {}; f[b] = f[b] || []; f[b].push([c, d, h]); a.addEventListener(b, h) } function X(a) { a = a.split("."); return [a[0], a.slice(1).sort()] }
	function Y(a, b, c, d, h) { var f = a.___ce = a.___ce || {}; if (b) f[b] && (f[b] = f[b].filter(function (f) { var l = f[0], k = f[1]; f = f[2]; if (h && f.guid !== h.guid || !ua(l, c) || d && d !== k) return !0; a.removeEventListener(b, f) })); else for (b in f) Y(a, b, c, d, h) }
	I.off = function (a, b, c) { var d = this; if (void 0 === a) this.each(function (a, b) { (D(b) || C(b) || M(b)) && Y(b) }); else if (F(a)) H(b) && (c = b, b = ""), L(P(a), function (a, h) { a = X(h); h = a[0]; var f = a[1], k = W[h] || V[h] || h; d.each(function (a, d) { (D(d) || C(d) || M(d)) && Y(d, k, f, b, c) }) }); else for (var h in a) this.off(h, a[h]); return this };
	I.on = function (a, b, c, d, h) {
		var f = this; if (!F(a)) { for (var l in a) this.on(l, b, c, a[l], h); return this } F(b) || (void 0 !== b && null !== b && (void 0 !== c && (d = c), c = b), b = ""); H(d) || (d = c, c = void 0); if (!d) return this; L(P(a), function (a, k) {
			a = X(k); k = a[0]; var q = a[1], l = W[k] || V[k] || k, x = k in W, xa = k in V; l && f.each(function (a, f) {
				if (D(f) || C(f) || M(f)) a = function ya(a) {
					if (a.target["___i" + a.type]) return a.stopImmediatePropagation(); if (!a.namespace || ua(q, a.namespace.split("."))) if (b || !(xa && (a.target !== f || a.___ot === l) || x && a.relatedTarget &&
						f.contains(a.relatedTarget))) { var k = f; if (b) { for (var z = a.target; !ka(z, b);) { if (z === f) return; z = z.parentNode; if (!z) return } k = z; a.___cd = !0 } a.___cd && Object.defineProperty(a, "currentTarget", { configurable: !0, get: function () { return k } }); Object.defineProperty(a, "data", { configurable: !0, get: function () { return c } }); z = d.call(k, a, a.___td); h && Y(f, l, q, b, ya); !1 === z && (a.preventDefault(), a.stopPropagation()) }
				}, a.guid = d.guid = d.guid || J.guid++, wa(f, l, q, b, a)
			})
		}); return this
	}; I.one = function (a, b, c, d) { return this.on(a, b, c, d, !0) };
	I.ready = function (a) { function b() { return setTimeout(a, 0, J) } "loading" !== m.readyState ? b() : m.addEventListener("DOMContentLoaded", b); return this }; I.trigger = function (a, b) { if (F(a)) { var c = X(a), d = c[0]; c = c[1]; var h = W[d] || V[d] || d; if (!h) return this; var f = va.test(h) ? "MouseEvents" : "HTMLEvents"; a = m.createEvent(f); a.initEvent(h, !0, !0); a.namespace = c.join("."); a.___ot = d } a.___td = b; var l = a.___ot in V; return this.each(function (b, c) { l && H(c[a.___ot]) && (c["___i" + a.type] = !0, c[a.___ot](), c["___i" + a.type] = !1); c.dispatchEvent(a) }) };
	function za(a) { return a.multiple && a.options ? Q(u.call(a.options, function (a) { return a.selected && !a.disabled && !a.parentNode.disabled }), "value") : a.value || "" } var Aa = /radio|checkbox/i; I.val = function (a) { return arguments.length ? this.each(function (b, c) { if ((b = c.multiple && c.options) || Aa.test(c.type)) { var d = r(a) ? w.call(a, String) : null === a ? [] : [String(a)]; b ? L(c.options, function (a, b) { b.selected = 0 <= d.indexOf(b.value) }, !0) : c.checked = 0 <= d.indexOf(c.value) } else c.value = void 0 === a || null === a ? "" : a }) : this[0] && za(this[0]) };
	I.clone = function () { return this.map(function (a, b) { return b.cloneNode(!0) }) }; I.detach = function (a) { O(this, a).each(function (a, c) { c.parentNode && c.parentNode.removeChild(c) }); return this }; var Ba = /^\s*<(\w+)[^>]*>/, Ca = /^<(\w+)\s*\/?>(?:<\/\1>)?$/; function G(a) { if (!F(a)) return []; if (Ca.test(a)) return [p(RegExp.$1)]; var b = Ba.test(a) && RegExp.$1; b = p("tr" == b ? "tbody" : "div"); b.innerHTML = a; return J(b.childNodes).detach().get() } J.parseHTML = G; I.empty = function () { return this.each(function (a, b) { for (; b.firstChild;)b.removeChild(b.firstChild) }) };
	function Z(a, b, c, d, h, f, l, x) { L(a, function (a, f) { L(J(f), function (a, f) { L(J(b), function (b, k) { var l = c ? k : f; k = c ? f : k; b = (c ? a : b) ? l.cloneNode(!0) : l; h ? k.insertBefore(b, d ? k.firstChild : null) : k.parentNode.insertBefore(b, d ? k : k.nextSibling) }, x) }, l) }, f); return b } I.after = function () { return Z(arguments, this, !1, !1, !1, !0, !0) }; I.append = function () { return Z(arguments, this, !1, !1, !0) }; I.appendTo = function (a) { return Z(arguments, this, !0, !1, !0) }; I.before = function () { return Z(arguments, this, !1, !0) };
	I.html = function (a) { return arguments.length ? void 0 === a ? this : this.each(function (b, c) { D(c) && (c.innerHTML = a) }) : this[0] && this[0].innerHTML }; I.insertAfter = function (a) { return Z(arguments, this, !0, !1, !1, !1, !1, !0) }; I.insertBefore = function (a) { return Z(arguments, this, !0, !0) }; I.prepend = function () { return Z(arguments, this, !1, !0, !0, !0, !0) }; I.prependTo = function (a) { return Z(arguments, this, !0, !0, !0, !1, !1, !0) }; I.remove = function (a) { O(this, a).detach().off(); return this }; I.replaceWith = function (a) { return this.before(a).remove() };
	I.replaceAll = function (a) { J(a).replaceWith(this); return this }; I.text = function (a) { return void 0 === a ? this[0] ? this[0].textContent : "" : this.each(function (b, c) { D(c) && (c.textContent = a) }) }; I.unwrap = function () { this.parent().each(function (a, b) { "BODY" !== b.tagName && (a = J(b), a.replaceWith(a.children())) }); return this }; I.wrapAll = function (a) { a = J(a); for (var b = a[0]; b.children.length;)b = b.firstElementChild; this.first().before(a); return this.appendTo(b) };
	I.wrap = function (a) { return this.each(function (b, c) { var d = J(a)[0]; J(c).wrapAll(b ? d.cloneNode(!0) : d) }) }; I.wrapInner = function (a) { return this.each(function (b, c) { b = J(c); c = b.contents(); c.length ? c.wrapAll(a) : b.append(a) }) }; I.offset = function () { var a = this[0]; if (a) return a = a.getBoundingClientRect(), { top: a.top + n.pageYOffset, left: a.left + n.pageXOffset } }; I.offsetParent = function () { return this.map(function (a, b) { for (a = b.offsetParent; a && "static" === S(a, "position");)a = a.offsetParent; return a || aa }) };
	I.children = function (a) { return O(J(R(Q(this, function (a) { return a.children }))), a) }; I.contents = function () { return J(R(Q(this, function (a) { return "IFRAME" === a.tagName ? [a.contentDocument] : "TEMPLATE" === a.tagName ? a.content.childNodes : a.childNodes }))) }; I.find = function (a) { return J(R(Q(this, function (b) { return B(a, b) }))) }; I.has = function (a) { var b = F(a) ? function (b, d) { return B(a, d).length } : function (b, d) { return d.contains(a) }; return this.filter(b) };
	I.is = function (a) { var b = N(a); return A.call(this, function (a, d) { return b.call(a, d, a) }) }; I.next = function (a, b, c) { return O(J(R(Q(this, "nextElementSibling", b, c))), a) }; I.nextAll = function (a) { return this.next(a, !0) }; I.nextUntil = function (a, b) { return this.next(b, !0, a) }; I.not = function (a) { var b = N(a); return this.filter(function (c, d) { return (!F(a) || D(d)) && !b.call(d, c, d) }) }; I.parent = function (a) { return O(J(R(Q(this, "parentNode"))), a) };
	I.index = function (a) { var b = a ? J(a)[0] : this[0]; a = a ? this : J(b).parent().children(); return v.call(a, b) }; I.closest = function (a) { var b = this.filter(a); if (b.length) return b; var c = this.parent(); return c.length ? c.closest(a) : b }; I.parents = function (a, b) { return O(J(R(Q(this, "parentElement", !0, b))), a) }; I.parentsUntil = function (a, b) { return this.parents(b, a) }; I.prev = function (a, b, c) { return O(J(R(Q(this, "previousElementSibling", b, c))), a) }; I.prevAll = function (a) { return this.prev(a, !0) };
	I.prevUntil = function (a, b) { return this.prev(b, !0, a) }; I.siblings = function (a) { return O(J(R(Q(this, function (a) { return J(a).parent().children().not(a) }))), a) }; "undefined" !== typeof exports ? module.exports = J : n.cash = n.$ = J;
})(); !function () { var u = "displayController", l = "hasActiveHover", f = "forcedOpen", w = { scoped: {}, currentX: 0, currentY: 0, previousX: 0, previousY: 0, mouseTrackingActive: !1, windowWidth: 0, windowHeight: 0, scrollTop: 0, scrollLeft: 0 }, h = { none: 0, top: 1, bottom: 2, left: 4, right: 8 }; function d() { var o = this; o.top = "auto", o.left = "auto", o.right = "auto", o.bottom = "auto", o.set = function (e, t) { $.isNumeric(t) && (o[e] = Math.round(t)) } } function i(o, i, n) { var s = null, r = w.scoped[i.popupId]; function c(e, t) { p(), o[0][l] || (e ? (t && (o[0][f] = !0), n.showTip(o)) : (r.tipOpenImminent = !0, s = setTimeout(function () { var e, t; s = null, e = Math.abs(w.previousX - w.currentX), t = Math.abs(w.previousY - w.currentY), e + t < i.intentSensitivity ? n.showTip(o) : (w.previousX = w.currentX, w.previousY = w.currentY, c()) }, i.intentPollInterval))) } function p() { s = clearTimeout(s), r.delayInProgress = !1 } this.show = c, this.hide = function (e) { p(), r.tipOpenImminent = !1, o[0][l] && (o[0][f] = !1, e ? n.hideTip(o) : (r.delayInProgress = !0, s = setTimeout(function () { s = null, n.hideTip(o), w.delayInProgress = !1 }, i.closeDelay))) }, this.cancel = p, this.resetPosition = function () { n.resetPosition(o) } } function e() { this.compute = function (e, t, o, i, n) { var s = t.split("-")[0], r = new d, c = function (e, t) { var o, i, n = e.offset(), s = e.outerWidth(), r = e.outerHeight(); switch (t) { case "n": o = n.left + s / 2, i = n.top; break; case "e": o = n.left + s, i = n.top + r / 2; break; case "s": o = n.left + s / 2, i = n.top + r; break; case "w": o = n.left, i = n.top + r / 2; break; case "nw": o = n.left, i = n.top; break; case "ne": o = n.left + s, i = n.top; break; case "sw": o = n.left, i = n.top + r; break; case "se": o = n.left + s, i = n.top + r }return { top: i, left: o } }(e, s); switch (t) { case "n": r.set("left", c.left - o / 2), r.set("bottom", w.windowHeight - c.top + n); break; case "e": r.set("left", c.left + n), r.set("top", c.top - i / 2); break; case "s": r.set("left", c.left - o / 2), r.set("top", c.top + n); break; case "w": r.set("top", c.top - i / 2), r.set("right", w.windowWidth - c.left + n); break; case "nw": r.set("bottom", w.windowHeight - c.top + n), r.set("right", w.windowWidth - c.left - 20); break; case "ne": r.set("left", c.left - 20), r.set("bottom", w.windowHeight - c.top + n); break; case "sw": r.set("top", c.top + n), r.set("right", w.windowWidth - c.left - 20); break; case "se": r.set("left", c.left - 20), r.set("top", c.top + n) }return r } } function n(r) { var c = new e, p = $("#" + r.popupId), o = w.scoped[r.popupId]; function i(e) { o.isClosing = !0, o.activeHover = null, o.isTipOpen = !1, o.desyncTimeout = clearInterval(o.desyncTimeout), e[0][l] = !1, e[0][f] = !1, p.hide(); e = new d; o.isClosing = !1, p.removeClass(), e.set("top", w.currentY + r.offset), e.set("left", w.currentX + r.offset), p.css(e) } function n(i) { var e; r.smartPlacement ? (e = $.fn.powerTip.smartPlacementLists[r.placement], $.each(e, function (e, t) { var o = function (e, t, o) { var i = w.scrollTop, n = w.scrollLeft, s = i + w.windowHeight, r = n + w.windowWidth, c = h.none; (e.top < i || Math.abs(e.bottom - w.windowHeight) - o < i) && (c |= h.top); (e.top + o > s || Math.abs(e.bottom - w.windowHeight) > s) && (c |= h.bottom); (e.left < n || e.right + t > r) && (c |= h.left); (e.left + t > r || e.right < n) && (c |= h.right); return c }(s(i, t), p.outerWidth() || r.defaultSize[0], p.outerHeight() || r.defaultSize[1]); if (o === h.none) return !1 })) : (s(i, r.placement), r.placement) } function s(e, t) { var o, i, n = 0, s = new d; for (s.set("top", 0), s.set("left", 0), p.css(s); o = p.outerWidth() || r.defaultSize[0], i = p.outerHeight() || r.defaultSize[1], s = c.compute(e, t, o, i, r.offset), p.css(s), ++n <= 5 && (o !== p.outerWidth() || i !== p.outerHeight());); return s } function a() { var e = !1; !o.isTipOpen || o.isClosing || o.delayInProgress || (e = !1 === o.activeHover[0][l] || o.activeHover.is(":disabled") || !(t(o.activeHover) || o.activeHover.is(":focus") || o.activeHover[0][f] || t(p)) ? !0 : e) && i(o.activeHover) } o || (w.scoped[r.popupId] = o = {}), 0 === p.length && (p = $('<div id="' + r.popupId + '"/>'), $("body").append(p)), p.on({ mouseenter: function () { o.activeHover && o.activeHover[0][u].cancel() }, mouseleave: function () { o.activeHover && o.activeHover[0][u].hide() } }), this.showTip = function (e) { e[0][l] = !0, function e(t) { if (!t[0][l]) return; if (o.isTipOpen) return o.isClosing || i(o.activeHover), void setTimeout(function () { e(t) }, 100); p.empty(); r.preRender && r.preRender(t[0]); o.activeHover = t; o.isTipOpen = !0; n(t); p.show(); o.desyncTimeout || (o.desyncTimeout = setInterval(a, 500)) }(e) }, this.hideTip = i, this.resetPosition = n } function s(e) { w.currentX = e.pageX, w.currentY = e.pageY } function t(e) { var t = e.offset(); return w.currentX >= t.left && w.currentX <= t.left + e.width() && w.currentY >= t.top && w.currentY <= t.top + e.height() } $.fn.powerTip = function (e) { if (!this.length) return this; var t = Object.assign({}, $.fn.powerTip.defaults, e), o = new n(t); return function () { { var e; w.mouseTrackingActive || (w.mouseTrackingActive = !0, e = $(window), w.scrollLeft = window.scrollX, w.scrollTop = window.scrollY, w.windowWidth = e.width(), w.windowHeight = e.height(), document.addEventListener("mousemove", s), window.addEventListener("resize", function () { w.windowWidth = e.width(), w.windowHeight = e.height() }, { passive: !0 }), window.addEventListener("scroll", function () { var e = window.scrollX, t = window.scrollY; e !== w.scrollLeft && (w.currentX += e - w.scrollLeft, w.scrollLeft = e), t !== w.scrollTop && (w.currentY += t - w.scrollTop, w.scrollTop = t) }, { passive: !0 })) } }(), this.each(function () { var e = $(this); this[u] && $.powerTip.destroy(e), this[u] = new i(e, t, o) }), this.on({ mouseenter: function (e) { $.powerTip.show(this, e) }, mouseleave: function () { $.powerTip.hide(this) } }), this }, $.fn.powerTip.defaults = { popupId: "powerTip", intentSensitivity: 7, intentPollInterval: 150, closeDelay: 150, placement: "n", smartPlacement: !0, defaultSize: [260, 120], offset: 10 }, $.fn.powerTip.smartPlacementLists = { n: ["n", "ne", "nw", "s"], e: ["e", "ne", "se", "w", "nw", "sw", "n", "s", "e"], s: ["s", "se", "sw", "n"], w: ["w", "nw", "sw", "e", "ne", "se", "n", "s", "w"], nw: ["nw", "w", "sw", "n", "s", "se", "nw"], ne: ["ne", "e", "se", "n", "s", "sw", "ne"], sw: ["sw", "w", "nw", "s", "n", "ne", "sw"], se: ["se", "e", "ne", "s", "n", "nw", "se"] }, $.powerTip = { show: function (e, t) { return t ? (s(t), w.previousX = t.pageX, w.previousY = t.pageY, $(e)[0][u].show()) : $(e).first()[0][u].show(!0, !0), e }, reposition: function (e) { return $(e).first()[0][u].resetPosition(), e }, hide: function (e, t) { return $(e).first()[0][u].hide(t), e }, destroy: function (e) { return $(e).off(".powertip").each(function () { delete this[u], delete this[l], delete this[f] }), e } }, $.powerTip.showTip = $.powerTip.show, $.powerTip.closeTip = $.powerTip.hide }();
// https://github.com/ornicar/howler.js/tree/2.0-lila-trim2
!function () { "use strict"; var e = function () { this.init() }; e.prototype = { init: function () { var e = this || n; return e._codecs = {}, e._howls = [], e._canPlayEvent = "canplaythrough", e.noAudio = !1, e.usingWebAudio = !0, e.autoSuspend = !0, e.ctx = null, e.mobileAutoEnable = !0, e._setup(), e }, unload: function () { for (var e = this || n, t = e._howls.length - 1; t >= 0; t--)e._howls[t].unload(); return e.usingWebAudio && e.ctx && void 0 !== e.ctx.close && (e.ctx.close(), e.ctx = null, d()), e }, codecs: function (e) { return (this || n)._codecs[e.replace(/^x-/, "")] }, _setup: function () { var e = this || n; if (e.state = e.ctx && e.ctx.state || "running", e._autoSuspend(), !e.usingWebAudio) if ("undefined" != typeof Audio) try { void 0 === (t = new Audio).oncanplaythrough && (e._canPlayEvent = "canplay") } catch (o) { e.noAudio = !0 } else e.noAudio = !0; try { var t; (t = new Audio).muted ? e.noAudio = !0 : e._codecs = { mp3: !(!t.canPlayType("audio/mpeg;").replace(/^no$/, "") && !t.canPlayType("audio/mp3;").replace(/^no$/, "")), ogg: !!t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, "") } } catch (o) { } return e }, _enableMobileAudio: function () { var e = this || n; if (e._mobileEnabled || !e.ctx || !/iPhone|iPad|iPod|Android|BlackBerry|BB10|Silk|Mobi/i.test(navigator.userAgent) && !("ontouchend" in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0)) return; e._mobileEnabled = !1, e._mobileUnloaded || 44100 === e.ctx.sampleRate || (e._mobileUnloaded = !0, e.unload()), e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050); const t = ["touchstart", "touchend", "click"]; var o = function () { var n = e.ctx.createBufferSource(); n.buffer = e._scratchBuffer, n.connect(e.ctx.destination), void 0 === n.start ? n.noteOn(0) : n.start(0), n.onended = function () { n.disconnect(0), e._mobileEnabled = !0, e.mobileAutoEnable = !1, t.forEach(e => document.removeEventListener(e, o, !0)) } }; return t.forEach(e => document.addEventListener(e, o, !0)), e }, _autoSuspend: function () { var e = this; if (e.autoSuspend && e.ctx && void 0 !== e.ctx.suspend && n.usingWebAudio) { for (var t = 0; t < e._howls.length; t++)if (e._howls[t]._webAudio) return e._howls[t]._sounds.length > 0; return e._suspendTimer && clearTimeout(e._suspendTimer), e._suspendTimer = setTimeout((function () { e.autoSuspend && (e._suspendTimer = null, e.state = "suspending", e.ctx.suspend().then((function () { e.state = "suspended", e._resumeAfterSuspend && (delete e._resumeAfterSuspend, e._autoResume()) }))) }), 9e4), e } }, _autoResume: function () { var e = this; if (e.ctx && void 0 !== e.ctx.resume && n.usingWebAudio) return "running" === e.state && e._suspendTimer ? (clearTimeout(e._suspendTimer), e._suspendTimer = null) : "suspended" === e.state ? (e.state = "resuming", e.ctx.resume().then((function () { e.state = "running", e._howls.forEach(e => e._emit("resume")) })), e._suspendTimer && (clearTimeout(e._suspendTimer), e._suspendTimer = null)) : "suspending" === e.state && (e._resumeAfterSuspend = !0), e } }; var n = new e, t = function (e) { e.src && 0 !== e.src.length ? this.init(e) : console.error("An array of source files must be passed with any new Howl.") }; t.prototype = { init: function (e) { var t = this; return n.ctx || d(), t._html5 = !1, t._pool = 5, t._preload = !0, t._src = "string" != typeof e.src ? e.src : [e.src], t._volume = void 0 !== e.volume ? e.volume : 1, t._duration = 0, t._state = "unloaded", t._sounds = [], t._endTimers = {}, t._queue = [], t._onload = t._onpause = t._onplay = t._onstop = t._onvolume = t._onresume = t._onend = [], t._webAudio = n.usingWebAudio && !t._html5, void 0 !== n.ctx && n.ctx && n.mobileAutoEnable && n._enableMobileAudio(), n._howls.push(t), t._preload && t.load(), t }, load: function () { var e = this, t = null; if (!n.noAudio) { "string" == typeof e._src && (e._src = [e._src]); for (var u = 0; u < e._src.length; u++) { var i = e._src[u], d = /\.([^.]+)$/.exec(i.split("?", 1)[0]); if (d && (d = d[1].toLowerCase()), n.codecs(d)) { t = e._src[u]; break } } if (t) return e._src = t, e._state = "loading", new o(e), e._webAudio && r(e), e } }, play: function () { var e = this, t = e._inactiveSound(); if ("loaded" !== e._state) return e._queue.push({ event: "play", action() { e.play() } }), t._id; e._webAudio && n._autoResume(), t._ended = !1; var o = t._node; if (e._webAudio) { var u = function () { e._refreshBuffer(t), o.gain.setValueAtTime(t._volume, n.ctx.currentTime), t._playStart = n.ctx.currentTime, void 0 === o.bufferSource.start ? o.bufferSource.noteGrainOn(0, 0, e._duration) : o.bufferSource.start(0, 0, e._duration), e._endTimers[t._id] = setTimeout(e._ended.bind(e, t), 1e3 * e._duration), setTimeout((function () { e._emit("play", t._id) }), 0) }, r = "running" === n.state; "loaded" === e._state && r ? u() : (e.on(r ? "load" : "resume", u, r ? t._id : null, 1), e._clearTimer(t._id)) } else { var i = function () { o.currentTime = 0, o.volume = t._volume, setTimeout((function () { o.play(), e._endTimers[t._id] = setTimeout(e._ended.bind(e, t), 1e3 * e._duration), e._emit("play", t._id) }), 0) }, d = "loaded" === e._state; if (4 === o.readyState || d) i(); else { var s = function () { i(), o.removeEventListener(n._canPlayEvent, s, !1) }; o.addEventListener(n._canPlayEvent, s, !1), e._clearTimer(t._id) } } return t._id }, stop: function (e) { var n = this; if ("loaded" !== n._state) return n._queue.push({ event: "stop", action() { n.stop(e) } }), n; for (var t = n._getSoundIds(e), o = 0; o < t.length; o++) { n._clearTimer(t[o]); var u = n._soundById(t[o]); if (u && (u._ended = !0, u._node)) if (n._webAudio) { if (!u._node.bufferSource) return n._emit("stop", u._id), n; void 0 === u._node.bufferSource.stop ? u._node.bufferSource.noteOff(0) : u._node.bufferSource.stop(0), n._cleanBuffer(u._node) } else isNaN(u._node.duration) && u._node.duration !== 1 / 0 || (u._node.currentTime = u._start || 0, u._node.pause()); u && n._emit("stop", u._id) } return n }, volume: function (e) { var t = this; return "loaded" !== t._state ? (t._queue.push({ event: "volume", action() { t.volume.apply(t, [e]) } }), t) : (t._volume = e, t._sounds.forEach((function (o) { o._volume = e, t._webAudio && o._node ? o._node.gain.setValueAtTime(e, n.ctx.currentTime) : o._node && (o._node.volume = e), t._emit("volume", o._id) })), t) }, playing: function (e) { return "number" == typeof e ? !!this._soundById(e) : this._sounds.length > 0 }, state: function () { return this._state }, on: function (e, n, t, o) { this["_on" + e].push({ id: t, fn: n, once: !!o }) }, _emit: function (e, n, t) { for (var o = this["_on" + e], u = o.length - 1; u >= 0; u--)o[u].id && o[u].id !== n && "load" !== e || (setTimeout(function (e) { e.call(this, n, t) }.bind(this, o[u].fn), 0), o[u].once && o.splice(u, 1)) }, _loadQueue: function () { var e = this; if (e._queue.length > 0) { var n = e._queue[0]; e.on(n.event, (function () { e._queue.shift(), e._loadQueue() }), null, 1), n.action() } return e }, _ended: function (e) { var t = this; return t._emit("end", e._id), t._webAudio && (e._ended = !0, t._clearTimer(e._id), t._cleanBuffer(e._node), n._autoSuspend()), t._webAudio || t.stop(e._id), t }, _clearTimer: function (e) { var n = this; return n._endTimers[e] && (clearTimeout(n._endTimers[e]), delete n._endTimers[e]), n }, _soundById: function (e) { for (var n = this, t = 0; t < n._sounds.length; t++)if (e === n._sounds[t]._id) return n._sounds[t]; return null }, _inactiveSound: function () { var e = this; e._drain(); for (var n = 0; n < e._sounds.length; n++)if (e._sounds[n]._ended) return e._sounds[n].reset(); return new o(e) }, _drain: function () { var e = this, n = e._pool, t = 0; if (!(e._sounds.length < n)) { var o = e._sounds.reduce((e, n) => e + (n._ended ? 1 : 0), 0); for (t = e._sounds.length - 1; t >= 0; t--) { if (o <= n) return; e._sounds[t]._ended && (e._webAudio && e._sounds[t]._node && e._sounds[t]._node.disconnect(0), e._sounds.splice(t, 1), o--) } } }, _getSoundIds: function (e) { if (void 0 === e) { for (var n = [], t = 0; t < this._sounds.length; t++)n.push(this._sounds[t]._id); return n } return [e] }, _refreshBuffer: function (e) { return e._node.bufferSource = n.ctx.createBufferSource(), e._node.bufferSource.buffer = u[this._src], e._panner ? e._node.bufferSource.connect(e._panner) : e._node.bufferSource.connect(e._node), this }, _cleanBuffer: function (e) { var n = this; if (n._scratchBuffer) { e.bufferSource.onended = null, e.bufferSource.disconnect(0); try { e.bufferSource.buffer = n._scratchBuffer } catch (t) { } } return e.bufferSource = null, n } }; var o = function (e) { this._parent = e, this.init() }; o.prototype = { init: function () { var e = this, n = e._parent; return e._volume = n._volume, e._ended = !0, e._id = Math.round(Date.now() * Math.random()), n._sounds.push(e), e.create(), e }, create: function () { var e = this, t = e._parent, o = e._volume; return t._webAudio ? (e._node = n.ctx.createGain ? n.ctx.createGain() : n.ctx.createGainNode(), e._node.gain.setValueAtTime(o, n.ctx.currentTime), e._node.connect(n.ctx.destination)) : (e._node = new Audio, e._loadFn = e._loadListener.bind(e), e._node.addEventListener(n._canPlayEvent, e._loadFn, !1), e._node.src = t._src, e._node.preload = "auto", e._node.volume = o, e._node.load()), e }, reset: function () { var e = this, n = e._parent; return e._volume = n._volume, e._ended = !0, e._id = Math.round(Date.now() * Math.random()), e }, _loadListener: function () { var e = this, t = e._parent; t._duration = Math.ceil(10 * e._node.duration) / 10, "loaded" !== t._state && (t._state = "loaded", t._emit("load"), t._loadQueue()), e._node.removeEventListener(n._canPlayEvent, e._loadFn, !1) } }; var u = {}, r = function (e) { var t = e._src; u[t] ? (e._duration = u[t].duration, i(e)) : fetch(t, {}).then(t => { t.ok ? t.arrayBuffer().then(t => n.ctx.decodeAudioData(t, n => { n && e._sounds.length > 0 && (u[e._src] = n, i(e, n)) })) : Promise.reject() }).catch(() => { e._html5 = !0, e._webAudio = !1, e._sounds = [], delete u[t], e.load() }) }, i = function (e, n) { n && !e._duration && (e._duration = n.duration), "loaded" !== e._state && (e._state = "loaded", e._emit("load"), e._loadQueue()) }, d = function () { try { "undefined" != typeof AudioContext ? n.ctx = new AudioContext : "undefined" != typeof webkitAudioContext ? n.ctx = new webkitAudioContext : n.usingWebAudio = !1 } catch (t) { n.usingWebAudio = !1 } var e = /iP(hone|od|ad)/.test(navigator) && navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/) ? parseInt(appVersion[1], 10) : null; e && e < 9 && !/safari/.test(navigator.userAgent.toLowerCase()) && (n.usingWebAudio = !1), n._setup() }; window.Howler = n, window.Howl = t }();
!function () { for (var e, t = { 8: "backspace", 9: "tab", 13: "enter", 16: "shift", 17: "ctrl", 18: "alt", 20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home", 37: "left", 38: "up", 39: "right", 40: "down", 45: "ins", 46: "del", 91: "meta", 93: "meta", 224: "meta" }, n = { 106: "*", 107: "+", 109: "-", 110: ".", 111: "/", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, a = { option: "alt", command: "meta", return: "enter", escape: "esc", plus: "+", mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl" }, r = 1; r < 20; ++r)t[111 + r] = "f" + r; for (r = 0; r <= 9; ++r)t[r + 96] = r.toString(); function o(e) { if ("keypress" == e.type) { var a = String.fromCharCode(e.which); return e.shiftKey || (a = a.toLowerCase()), a } return t[e.which] ? t[e.which] : n[e.which] ? n[e.which] : String.fromCharCode(e.which).toLowerCase() } function i(e) { return "shift" == e || "ctrl" == e || "alt" == e || "meta" == e } function c(n, a, r) { return r || (r = function () { if (!e) for (var n in e = {}, t) n > 95 && n < 112 || t.hasOwnProperty(n) && (e[t[n]] = n); return e }()[n] ? "keydown" : "keypress"), "keypress" == r && a.length && (r = "keydown"), r } function s(e, t) { var n, r, o, s = []; for (n = function (e) { return "+" === e ? ["+"] : (e = e.replace(/\+{2}/g, "+plus")).split("+") }(e), o = 0; o < n.length; ++o)r = n[o], a[r] && (r = a[r]), i(r) && s.push(r); return { key: r, modifiers: s, action: t = c(r, s, t) } } function l(e) { var t = this; if (e = e || document, !(t instanceof l)) return new l(e); t.target = e, t._callbacks = {}; var n, a = {}, r = !1, c = !1, u = !1; function f(e) { e = e || {}; var t, n = !1; for (t in a) e[t] ? n = !0 : a[t] = 0; n || (u = !1) } function h(e, n, r, o, c, s) { var l, u, f, h, p = [], y = r.type; if (!t._callbacks[e]) return []; for ("keyup" == y && i(e) && (n = [e]), l = 0; l < t._callbacks[e].length; ++l)if (u = t._callbacks[e][l], (o || !u.seq || a[u.seq] == u.level) && y == u.action && ("keypress" == y && !r.metaKey && !r.ctrlKey || (f = n, h = u.modifiers, f.sort().join(",") === h.sort().join(",")))) { var d = !o && u.combo == c, m = o && u.seq == o && u.level == s; (d || m) && t._callbacks[e].splice(l, 1), p.push(u) } return p } function p(e, t, n) { const a = t.target; ("esc" == n || "INPUT" != a.tagName && "SELECT" != a.tagName && "TEXTAREA" != a.tagName && !a.isContentEditable) && (e(), t.preventDefault(), t.stopPropagation()) } function y(e) { "number" != typeof e.which && (e.which = e.keyCode); var n = o(e); n && ("keyup" != e.type || r !== n ? t._handleKey.call(t, n, function (e) { var t = []; return e.shiftKey && t.push("shift"), e.altKey && t.push("alt"), e.ctrlKey && t.push("ctrl"), e.metaKey && t.push("meta"), t }(e), e) : r = !1) } function d(e, t, i, c) { function l(t) { return function () { u = t, ++a[e], clearTimeout(n), n = setTimeout(f, 1e3) } } function h(t) { p(i, t, e), "keyup" !== c && (r = o(t)), setTimeout(f, 10) } a[e] = 0; for (var y = 0; y < t.length; ++y) { var d = y + 1 === t.length ? h : l(c || s(t[y + 1]).action); m(t[y], d, c, e, y) } } function m(e, n, a, r, o) { var i, c = (e = e.replace(/\s+/g, " ")).split(" "); c.length > 1 ? d(e, c, n, a) : (i = s(e, a), t._callbacks[i.key] = t._callbacks[i.key] || [], h(i.key, i.modifiers, { type: i.action }, r, e, o), t._callbacks[i.key][r ? "unshift" : "push"]({ callback: n, modifiers: i.modifiers, action: i.action, seq: r, level: o, combo: e })) } t._handleKey = function (e, t, n) { var a, r = h(e, t, n), o = {}, s = 0, l = !1; for (a = 0; a < r.length; ++a)r[a].seq && (s = Math.max(s, r[a].level)); for (a = 0; a < r.length; ++a)if (r[a].seq) { if (r[a].level != s) continue; l = !0, o[r[a].seq] = 1, p(r[a].callback, n, r[a].combo) } else l || p(r[a].callback, n, r[a].combo); var y = "keypress" == n.type && c; n.type != u || i(e) || y || f(o), c = l && "keydown" == n.type }, t._bindMultiple = function (e, t, n) { e.forEach(e => m(e, t, n)) }, e.addEventListener("keypress", y), e.addEventListener("keydown", y), e.addEventListener("keyup", y) } l.prototype.bind = function (e, t, n) { return this._bindMultiple.call(this, e instanceof Array ? e : [e], t, n), this }, window.Mousetrap = new l }(); "use strict"; (() => {
	var Tt = Object.defineProperty; var Te = (e, t) => { for (var o in t) Tt(e, o, { get: t[o], enumerable: !0 }) }; var a = { date: "2023-06-02T11:53:03+00:00", commit: "fdff39af15762cec7437d14831d6650d98299c48", message: "rating range bounds in lobby setup" }; var N = "\uE025"; var Se = "\uE038"; var $e = "\uE03A"; var Me = "\uE03F"; var Ce = "\uE048"; var Le = "\uE04D"; var Ee = "\uE056"; var Ae = "\uE05A"; var Pe = "\uE065"; var F = {}; Te(F, { init: () => ee, initAll: () => B, initWith: () => Ie }); var De = e => `lichess-${e}`, U = (e, t) => e[De(t)], S = (e, t, o) => e[De(t)] = o; var He = ["a", "b", "c", "d", "e", "f", "g", "h"], Z = ["1", "2", "3", "4", "5", "6", "7", "8"]; var eo = [...Z].reverse(), Mt = Array.prototype.concat(...He.map(e => Z.map(t => e + t))); var Ct = e => [e.charCodeAt(0) - 97, e.charCodeAt(1) - 49], L = e => { if (e) return e[1] === "@" ? [e.slice(2, 4)] : [e.slice(0, 2), e.slice(2, 4)] }, to = Mt.map(Ct); var ee = e => { let [t, o, n] = e.getAttribute("data-state").split(","); Ie(e, t, o, n) }, Ie = (e, t, o, n) => { window.Chessground ? S(e, "chessground", window.Chessground(e, { orientation: o, coordinates: !1, viewOnly: !e.getAttribute("data-playable"), fen: t, lastMove: L(n), drawable: { enabled: !1, visible: !1 } })) : setTimeout(() => ee(e), 500) }, B = e => Array.from((e || document).getElementsByClassName("mini-board--init")).forEach(t => { t.classList.remove("mini-board--init"), ee(t) }); var j = {}; Te(j, { finish: () => de, init: () => ce, initAll: () => R, update: () => le }); var te = e => e.includes(" w") ? "white" : "black"; function E(e, t) { let o = U(e, "clock"); o ? o.set(t) : S(e, "clock", new ne(e, t)) } var ne = class { constructor(t, o) { this.el = t; this.opts = o; this.set = t => { this.opts = t, this.target = t.time * 1e3 + Date.now(), this.render(), clearInterval(this.interval), t.pause || (this.interval = setInterval(this.render, 1e3)) }; this.render = () => { document.body.contains(this.el) ? (this.el.textContent = Lt(this.target - Date.now()), this.el.classList.toggle("clock--run", !this.opts.pause)) : clearInterval(this.interval) }; this.target = o.time * 1e3 + Date.now(), o.pause || (this.interval = setInterval(this.render, 1e3)), this.render() } }, Lt = e => { let t = new Date(Math.max(0, e + 500)), o = t.getUTCHours(), n = t.getUTCMinutes(), s = t.getUTCSeconds(); return o > 0 ? o + ":" + oe(n) + ":" + oe(s) : n + ":" + oe(s) }, oe = e => (e < 10 ? "0" : "") + e; var se = e => e !== void 0, ie = e => e != null; var _e = e => { let t; return () => (t === void 0 && (t = e()), t) }; var Et = { Accept: "application/vnd.lichess.v5+json" }, At = { cache: "no-cache", credentials: "same-origin" }, Pt = { "X-Requested-With": "XMLHttpRequest" }, Oe = e => { if (e.ok) return e; throw e.status == 429 ? new Error("Too many requests") : e.status == 413 ? new Error("The uploaded file is too large") : new Error(`Error ${e.status}`) }, Ne = (e, t = {}) => fetch(e, { headers: { ...Et }, ...t }).then(o => Oe(o).json()); var b = (e, t = {}) => Dt(e, t).then(o => Oe(o).text()), Dt = (e, t = {}) => fetch(e, { ...At, headers: { ...Pt }, ...t }), Ue = e => new Promise((t, o) => { let n = document.body.getAttribute("data-nonce"), s = document.createElement("script"); n && s.setAttribute("nonce", n), s.onload = t, s.onerror = o, s.src = e, document.head.append(s) }), Be = e => { let t = new FormData; for (let o of Object.keys(e)) se(e[o]) && t.append(o, e[o]); return t }, Fe = (e, t) => { let o = new URLSearchParams; for (let s of Object.keys(t)) se(t[s]) && o.append(s, t[s]); let n = o.toString(); return n ? `${e}?${n}` : e }, Re = (e, t) => { let o = e.getAttribute("action"), n = new FormData(e); return t != null && t.name && (t != null && t.value) && n.set(t.name, t.value), o ? b(o, { method: e.method, body: n }) : Promise.reject(`Form has no action: ${e}`) }; function P(e, t, o) { let n = ["mousemove", "touchstart"], s = !1, i = !0, r = performance.now(), c = () => { i || o(), i = !0, r = performance.now(), d() }, l = () => { s || (n.forEach(p => document.addEventListener(p, c)), s = !0) }, d = () => { s && (n.forEach(p => document.removeEventListener(p, c)), s = !1) }; setInterval(() => { i && performance.now() - r > e && (t(), i = !1), l() }, 1e4) } var je = () => { try { let e = window.crypto.getRandomValues(new Uint8Array(9)); return btoa(String.fromCharCode(...e)).replace(/[/+]/g, "_") } catch (e) { return Math.random().toString(36).slice(2, 12) } }; var Ht = je(), x = Ht; var qe = !1, Ve = e => { let t; if (typeof e == "string") t = e; else if (t = e.url, e.cookie) { let n = [encodeURIComponent(e.cookie.name) + "=" + e.cookie.value, "; max-age=" + e.cookie.maxAge, "; path=/", "; domain=" + location.hostname].join(""); document.cookie = n } let o = "//" + location.host + "/" + t.replace(/^\//, ""); qe = o, location.href = o }, re = { expected: !1 }, y = () => { qe || (re.expected = !0, lichess.socket.disconnect(), location.hash ? location.reload() : location.assign(location.href)) }; var ze = e => { let t = { get: o => e.getItem(o), set: (o, n) => e.setItem(o, n), fire: (o, n) => e.setItem(o, JSON.stringify({ sri: x, nonce: Math.random(), value: n })), remove: o => e.removeItem(o), make: o => ({ get: () => t.get(o), set: n => t.set(o, n), fire: n => t.fire(o, n), remove: () => t.remove(o), listen: n => window.addEventListener("storage", s => { if (s.key !== o || s.storageArea !== e || s.newValue === null) return; let i; try { i = JSON.parse(s.newValue) } catch (r) { return } i != null && i.sri && i.sri !== x && n(i) }) }), boolean: o => ({ get: () => t.get(o) == "1", getOrDefault: n => { let s = t.get(o); return s === null ? n : s == "1" }, set: n => t.set(o, n ? "1" : "0"), toggle: () => t.set(o, t.get(o) == "1" ? "0" : "1") }) }; return t }, m = ze(window.localStorage), We = ze(window.sessionStorage); function D(e, t) { return t === "always" ? !0 : m.get(e) ? !1 : (m.set(e, "1"), !0) } var It = WebSocket.prototype.send, M = class {
		constructor(t, o, n = {}) {
			this.url = t; this.pubsub = lichess.pubsub; this.ackable = new ae((t, o, n) => this.send(t, o, n)); this.lastPingTime = performance.now(); this.pongCount = 0; this.averageLag = 0; this.tryOtherUrl = !1; this.autoReconnect = !0; this.nbConnects = 0; this.storage = m.make("surl17"); this.resendWhenOpen = []; this.sign = t => { this._sign = t, this.ackable.sign(t) }; this.connect = () => { this.destroy(), this.autoReconnect = !0; let t = Fe(this.options.protocol + "//" + this.baseUrl() + this.url, { ...this.settings.params, v: this.version === !1 ? void 0 : this.version }); this.debug("connection attempt to " + t); try { } catch (o) { this.onError(o) } this.scheduleConnect(this.options.pingMaxLag) }; this.send = (t, o, n = {}, s = !1) => {
				let i = { t }; o !== void 0 && (n.withLag && (o.l = Math.round(this.averageLag)), n.millis >= 0 && (o.s = Math.round(n.millis * .1).toString(36)), i.d = o), n.ackable && (i.d = i.d || {}, this.ackable.register(t, i.d)); let r = JSON.stringify(i); if (!(t == "racerScore" && n.sign != this._sign)) {
					if (t == "move" && n.sign != this._sign) {
						let c; try {
							c = new Error().stack.split(`
`).join(" / ").replace(/\s+/g, " ")
						} catch (l) { c = `${l.message} ${navigator.userAgent}` } c.includes("round.nvui") || setTimeout(() => { D(`socket.rep.${Math.round(Date.now() / 1e3 / 3600 / 3)}`) ? this.send("rep", { n: `soc: ${r} ${c}` }) : lichess.socket.destroy() }, 1e4)
					} this.debug("send " + r), !this.ws || this.ws.readyState === WebSocket.CONNECTING ? s || this.resendWhenOpen.push([t, i.d, n]) : It.apply(this.ws, [r])
				}
			}; this.scheduleConnect = t => { this.options.idle && (t = 10 * 1e3 + Math.random() * 10 * 1e3), clearTimeout(this.pingSchedule), clearTimeout(this.connectSchedule), this.connectSchedule = setTimeout(() => { document.body.classList.add("offline"), document.body.classList.remove("online"), this.tryOtherUrl = !0, this.connect() }, t) }; this.schedulePing = t => { clearTimeout(this.pingSchedule), this.pingSchedule = setTimeout(this.pingNow, t) }; this.pingNow = () => { clearTimeout(this.pingSchedule), clearTimeout(this.connectSchedule); let t = this.options.isAuth && this.pongCount % 8 == 2 ? JSON.stringify({ t: "p", l: Math.round(.1 * this.averageLag) }) : "null"; try { this.ws.send(t), this.lastPingTime = performance.now() } catch (o) { this.debug(o, !0) } this.scheduleConnect(this.options.pingMaxLag) }; this.computePingDelay = () => this.options.pingDelay + (this.options.idle ? 1e3 : 0); this.pong = () => { clearTimeout(this.connectSchedule), this.schedulePing(this.computePingDelay()); let t = Math.min(performance.now() - this.lastPingTime, 1e4); this.pongCount++; let o = this.pongCount > 4 ? .1 : 1 / this.pongCount; this.averageLag += o * (t - this.averageLag), this.pubsub.emit("socket.lag", this.averageLag) }; this.handle = t => { if (t.v && this.version !== !1) { if (t.v <= this.version) { this.debug("already has event " + t.v); return } if (t.v > this.version + 1) return y(); this.version = t.v } switch (t.t || !1) { case !1: break; case "resync": y(); break; case "ack": this.ackable.onServerAck(t.d); break; default: this.settings.receive && this.settings.receive(t.t, t.d) || (this.pubsub.emit("socket.in." + t.t, t.d, t), this.settings.events[t.t] && this.settings.events[t.t](t.d || null, t)) } }; this.debug = (t, o = !1) => { (o || this.options.debug) && console.debug(t) }; this.destroy = () => { clearTimeout(this.pingSchedule), clearTimeout(this.connectSchedule), this.disconnect(), this.ws = void 0 }; this.disconnect = () => { let t = this.ws; t && (this.debug("Disconnect"), this.autoReconnect = !1, t.onerror = t.onclose = t.onopen = t.onmessage = () => { }, t.close()) }; this.onError = t => { this.options.debug = !0, this.debug(`error: ${t} ${JSON.stringify(t)}`), this.tryOtherUrl = !0, clearTimeout(this.pingSchedule) }; this.onSuccess = () => { if (this.nbConnects++, this.nbConnects == 1) { M.resolveFirstConnect(this.send); let t; P(10 * 60 * 1e3, () => { this.options.idle = !0, t = setTimeout(this.destroy, 2 * 60 * 60 * 1e3) }, () => { this.options.idle = !1, this.ws ? clearTimeout(t) : location.reload() }) } }; this.baseUrl = () => { return 'https://chessify.me' }; this.pingInterval = () => this.computePingDelay() + this.averageLag; this.getVersion = () => this.version; this.settings = { receive: n.receive, events: n.events || {}, params: { ...M.defaultParams, ...n.params || {} } }, this.options = { ...M.defaultOptions, ...n.options || {} }, this.version = o, this.pubsub.on("socket.send", this.send), this.connect()
		}
	}, h = M; h.defaultOptions = { idle: !1, pingMaxLag: 9e3, pingDelay: 2500, autoReconnectDelay: 3500, protocol: location.protocol === "https:" ? "wss:" : "ws:", isAuth: document.body.hasAttribute("user") }, h.defaultParams = { sri: x }, h.firstConnect = new Promise(t => { M.resolveFirstConnect = t }); var ae = class { constructor(t) { this.send = t; this.currentId = 1; this.messages = []; this.sign = t => this._sign = t; this.resend = () => { let t = performance.now() - 2500; this.messages.forEach(o => { o.at < t && this.send(o.t, o.d, { sign: this._sign }) }) }; this.register = (t, o) => { o.a = this.currentId++, this.messages.push({ t, d: o, at: performance.now() }) }; this.onServerAck = t => { this.messages = this.messages.filter(o => o.d.a !== t) }; setInterval(this.resend, 1200) } }; var ce = e => { if (!window.Chessground) setTimeout(() => ce(e), 200); else { let [t, o, n] = e.getAttribute("data-state").split(","), s = { coordinates: !1, viewOnly: !0, fen: t, orientation: o, lastMove: L(n), drawable: { enabled: !1, visible: !1 } }, i = $(e).removeClass("mini-game--init"), r = i.find(".cg-wrap"), c = te(t); S(r[0], "chessground", window.Chessground(r[0], s)), ["white", "black"].forEach(l => i.find(".mini-game__clock--" + l).each(function () { E(this, { time: parseInt(this.getAttribute("data-time")), pause: l != c || !Ge(t, l) }) })) } return e.getAttribute("data-live") }, Ge = (e, t) => t == "white" ? !e.includes("PPPPPPPP/RNBQKBNR") : !e.startsWith("rnbqkbnr/pppppppp"), R = e => { let t = Array.from((e || document).getElementsByClassName("mini-game--init")), o = t.map(ce).filter(n => n); o.length && h.firstConnect.then(n => n("startWatching", o.join(" "))) }, le = (e, t) => { let o = $(e), n = t.lm, s = U(e.querySelector(".cg-wrap"), "chessground"); s && s.set({ fen: t.fen, lastMove: L(n) }); let i = te(t.fen), r = (c, l) => { var d; isNaN(c) || E((d = o[0]) == null ? void 0 : d.querySelector(".mini-game__clock--" + l), { time: c, pause: l != i || !Ge(t.fen, l) }) }; r(t.wc, "white"), r(t.bc, "black") }, de = (e, t) => ["white", "black"].forEach(o => { let n = $(e).find(".mini-game__clock--" + o); n.data("managed") || n.replaceWith(`<span class="mini-game__result">${t ? t === o[0] ? 1 : 0 : "\xBD"}</span>`) }); function Ke(e, t) { if (t.length) if (e.includes("%s")) e = e.replace("%s", t[0]); else for (let o = 0; o < t.length; o++)e = e.replace("%" + (o + 1) + "$s", t[o]); return e } function Xe(e, t) { let o = e.split(/(%(?:\d\$)?s)/g); if (t.length) { let n = o.indexOf("%s"); if (n !== -1) o[n] = t[0]; else for (let s = 0; s < t.length; s++) { let i = o.indexOf("%" + (s + 1) + "$s"); i !== -1 && (o[i] = t[s]) } } return o } var ue = e => { let t = (o, ...n) => { let s = e[o]; return s ? Ke(s, n) : o }; return t.pluralSame = (o, n, ...s) => t.plural(o, n, n, ...s), t.plural = function (o, n, ...s) { let i = `${o}:${lichess.quantity(n)}`, r = e[i] || e[o]; return r ? Ke(r, s) : o }, t.noarg = o => e[o] || o, t.vdom = (o, ...n) => { let s = e[o]; return s ? Xe(s, n) : [o] }, t.vdomPlural = (o, n, ...s) => { let i = `${o}:${lichess.quantity(n)}`, r = e[i] || e[o]; return r ? Xe(r, s) : [o] }, t }, k = ue(lichess.siteI18n); var _t = [["nbYearsAgo", "inNbYears", 60 * 60 * 24 * 365, 1], ["nbMonthsAgo", "inNbMonths", 60 * 60 * 24 * 365 / 12, 1], ["nbWeeksAgo", "inNbWeeks", 60 * 60 * 24 * 7, 1], ["nbDaysAgo", "inNbDays", 60 * 60 * 24, 2], ["nbHoursAgo", "inNbHours", 60 * 60, 1], ["nbMinutesAgo", "inNbMinutes", 60, 1], ["nbSecondsAgo", "inNbSeconds", 1, 9], ["rightNow", "justNow", 1, 0]], Ye = e => e instanceof Date ? e : new Date(isNaN(e) ? e : parseInt(e)), Qe = e => { let t = Math.abs(e), o = _t.find(n => t >= n[2] * n[3]); return k.pluralSame(o[e < 0 ? 1 : 0], Math.floor(t / o[2])) }, Je, pe = () => Je = Je || (window.Intl && Intl.DateTimeFormat ? new Intl.DateTimeFormat(document.documentElement.lang, { year: "numeric", month: "short", day: "numeric", hour: "numeric", minute: "numeric" }).format : e => e.toLocaleString()), Ze = e => Qe((Date.now() - Ye(e).getTime()) / 1e3), me = e => requestAnimationFrame(() => { let t = Date.now();[].slice.call((e || document).getElementsByClassName("timeago"), 0, 99).forEach(o => { let n = o.classList, s = n.contains("abs"), i = n.contains("set"); if (o.lichessDate = o.lichessDate || Ye(o.getAttribute("datetime")), !i) { let r = pe()(o.lichessDate); s ? o.textContent = r : o.setAttribute("title", r), n.add("set"), (s || n.contains("once")) && n.remove("timeago") } if (!s) { let r = (t - o.lichessDate.getTime()) / 1e3; o.textContent = Qe(r), Math.abs(r) > 9999 && n.remove("timeago") } }) }), he = e => { me(), setTimeout(() => he(e * 1.1), e) }; var T = (e, t) => { window.requestIdleCallback ? window.requestIdleCallback(e, t ? { timeout: t } : void 0) : requestAnimationFrame(e) }, q = e => /[&<>"']/.test(e) ? e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/'/g, "&#39;").replace(/"/g, "&quot;") : e; var V, fe = () => { V && clearTimeout(V), V = void 0, $("#announce").remove() }, Nt = e => { fe(), e.msg && ($("body").append('<div id="announce" class="announce">' + q(e.msg) + (e.date ? '<time class="timeago" datetime="' + e.date + '"></time>' : "") + '<div class="actions"><a class="close">\xD7</a></div></div>').find("#announce .close").on("click", fe), V = setTimeout(fe, e.date ? new Date(e.date).getTime() - Date.now() : 5e3), e.date && lichess.contentLoaded()) }, H = Nt; function et() { $("#agreement form").on("submit", e => { let t = e.target; return Re(t), t.parentNode.remove(), !1 }) } var tt = () => window.matchMedia("(prefers-color-scheme: light)").media !== "not all"; var v = (e, t = {}) => { t = t || {}; let o = t.sameDomain ? "" : document.body.getAttribute("data-asset-url"), n = t.version || document.body.getAttribute("data-asset-version"); return o + "/assets" + (t.noVersion ? "" : "/_" + n) + "/" + e }, ge = new Map, z = (e, t) => { if (!ge.has(e)) { let o = document.createElement("link"); o.rel = "stylesheet", o.href = v(e), t && (o.media = `(prefers-color-scheme: ${t})`), ge.set(e, new Promise(n => { o.onload = () => n() })), document.head.append(o) } return ge.get(e) }, g = async e => { let t = $("body").data("theme"), o = (n, s) => z(`css/${e}.${document.dir || "ltr"}.${n}.${$("body").data("dev") ? "dev" : "min"}.css`, s); t === "system" ? tt() ? (await o("dark", "dark"), await o("light", "light")) : await o("dark") : await o(t) }, I = e => `compiled/${e}${$("body").data("dev") ? "" : ".min"}.js`, be = new Map, W = (e, t = {}) => (be.has(e) || be.set(e, Ue(v(e, t))), be.get(e)), w = e => W(I(e)), ot = async (e, t) => (await w(e), window[t]), G = async () => (g("complete"), await w("userComplete"), window.UserComplete), nt = () => (z("vendor/hopscotch/dist/css/hopscotch.min.css"), W("vendor/hopscotch/dist/js/hopscotch.min.js", { noVersion: !0 })); function ve(e) { return new Promise(t => requestAnimationFrame(() => { e.loadCss = g, t(window.LichessChat(document.querySelector(".mchat"), e)) })) } var st = '<div class="spinner" aria-label="loading"><svg viewBox="-2 -2 54 54"><g mask="url(#mask)" fill="none"><path id="a" stroke-width="3.779" d="m21.78 12.64c-1.284 8.436 8.943 12.7 14.54 17.61 3 2.632 4.412 4.442 5.684 7.93"/><path id="b" stroke-width="4.157" d="m43.19 36.32c2.817-1.203 6.659-5.482 5.441-7.623-2.251-3.957-8.883-14.69-11.89-19.73-0.4217-0.7079-0.2431-1.835 0.5931-3.3 1.358-2.38 1.956-5.628 1.956-5.628"/><path id="c" stroke-width="4.535" d="m37.45 2.178s-3.946 0.6463-6.237 2.234c-0.5998 0.4156-2.696 0.7984-3.896 0.6388-17.64-2.345-29.61 14.08-25.23 27.34 4.377 13.26 22.54 25.36 39.74 8.666"/></g></svg></div>'; var at = e => { var t; return (t = document.querySelector(".crosstable")) == null ? void 0 : t.contains(e) }, ct = (e, t) => o => { let n = ($(o).data("href") || o.href).replace(/\?.+$/, ""); t && t(n), b(n + "/mini").then(s => { let i = document.getElementById(e); i.innerHTML = s, lichess.contentLoaded(i) }) }, we = (e, t) => `<a class="btn-rack__btn" href="${e}" data-icon="${t}"></a>`, xe = (e, t) => $(e).removeClass("ulpt").powerTip({ preRender: ct("powerTip", o => { let n = o.slice(3), s = $(e).data("name") || $(e).html(); $("#powerTip").html('<div class="upt__info"><div class="upt__info__top"><span class="user-link offline">' + s + '</span></div></div><div class="upt__actions btn-rack">' + we("/@/" + n + "/tv", N) + we("/inbox/new?user=" + n, Ee) + we("/?user=" + n + "#friend", Ce) + '<a class="btn-rack__btn relation-button" disabled></a></div>') }), placement: t || e.getAttribute("data-pt-pos") || (at(e) ? "n" : "s") }), ye = e => $(e).removeClass("glpt").powerTip({ preRender: ct("miniGame", () => lichess.spinnerHtml), placement: at(e) ? "n" : "w", popupId: "miniGame" }); function it(e, t, o) { "ontouchstart" in window || (o(e), $.powerTip.show(e, t)) } function rt(e, t, o) { T(() => Array.prototype.forEach.call(e.querySelectorAll(t), n => o(n)), 800) } var Ut = { watchMouse() { document.body.addEventListener("mouseover", e => { let t = e.target; t.classList.contains("ulpt") ? it(t, e, xe) : t.classList.contains("glpt") && it(t, e, ye) }) }, manualGameIn(e) { rt(e, ".glpt", ye) }, manualGame: ye, manualUser: xe, manualUserIn(e) { rt(e, ".ulpt", xe) } }, K = Ut; var X = Object.create(null), Bt = { on(e, t) { (X[e] = X[e] || []).push(t) }, off(e, t) { let o = X[e]; if (o) { for (let n in o) if (o[n] === t) { o.splice(+n); break } } }, emit(e, ...t) { for (let o of X[e] || []) o.apply(null, t) } }, u = Bt; var J = () => /iPhone|iPod/.test(navigator.userAgent) || Rt(), Rt = () => (navigator == null ? void 0 : navigator.maxTouchPoints) > 2 && /iPad|Macintosh/.test(navigator.userAgent), xn = _e(() => window.matchMedia("(hover: hover) and (pointer: fine)").matches); var jt = new class { constructor() { this.soundSetSounds = new Map; this.standaloneSounds = new Map; this.soundSet = $("body").data("sound-set"); this.speechStorage = m.boolean("speech.enabled"); this.volumeStorage = m.make("sound-volume"); this.baseUrl = v("sound", { version: "_____1" }); this.loadOggOrMp3 = (e, t, o = !1) => (o ? this.standaloneSounds : this.soundSetSounds).set(e, new Howl({ src: ["ogg", "mp3"].map(n => `${t}.${n}`) })); this.loadStandard = (e, t) => { if (!this.enabled()) return; let o = e[0].toUpperCase() + e.slice(1); this.loadOggOrMp3(e, `${this.baseUrl}/${t || this.soundSet}/${o}`) }; this.getOrLoadSound = (e, t) => { var n; let o = (n = this.soundSetSounds.get(e)) != null ? n : this.standaloneSounds.get(e); return o || (this.loadStandard(e, t), o = this.soundSetSounds.get(e)), o }; this.setVolume = this.volumeStorage.set; this.getVolume = () => { let e = parseFloat(this.volumeStorage.get() || ""); return e >= 0 ? e : .7 }; this.enabled = () => this.soundSet !== "silent"; this.speech = e => (e !== void 0 && this.speechStorage.set(e), this.speechStorage.get()); this.say = (e, t = !1, o = !1, n = !1) => { if (t && speechSynthesis.cancel(), !this.speechStorage.get() && !o) return !1; let s = new SpeechSynthesisUtterance(e); return s.volume = this.getVolume(), s.lang = n ? document.documentElement.lang : "en-US", J() || (s.onstart = i => { var r; return (r = lichess.mic) == null ? void 0 : r.pause() }, s.onend = s.onerror = i => { var r; return (r = lichess.mic) == null ? void 0 : r.resume() }), speechSynthesis.speak(s), !0 }; this.sayOrPlay = (e, t) => this.say(t) || this.play(e); this.publish = () => u.emit("sound_set", this.soundSet); this.changeSet = e => { this.soundSet = e, this.soundSetSounds.clear(), this.publish() }; this.set = () => this.soundSet; this.soundSet == "music" && setTimeout(this.publish, 500) } preloadBoardSounds() { this.soundSet !== "music" && ["move", "capture", "check", "genericNotify"].forEach(e => this.loadStandard(e)) } play(e, t) { var i; if (!this.enabled()) return; let o = this.soundSet; if (o === "music" || this.speechStorage.get()) { if (["move", "capture", "check"].includes(e)) return; o = "standard" } let n = this.getOrLoadSound(e, o), s = () => n.volume(this.getVolume() * (t || 1)).play(); ((i = Howler.ctx) == null ? void 0 : i.state) === "suspended" ? Howler.ctx.resume().then(s) : s() } playOnce(e) { let t = () => { let o = lichess.storage.make("just-played"); Date.now() - parseInt(o.get(), 10) < 2e3 || (o.set("" + Date.now()), this.play(e)) }; document.hasFocus() ? t() : setTimeout(t, 10 + Math.random() * 500) } }, lt = jt; async function dt(e) { let t = e.store, o = await qt(e); function n(s) { return new Promise((i, r) => { let c = s(); c.onsuccess = l => i(l.target.result), c.onerror = l => r(l.target.result) }) } return { get(s) { let i = o.transaction(t, "readonly").objectStore(t); return n(i.get.bind(i, s)) }, put(s, i) { let r = o.transaction(t, "readwrite").objectStore(t); return n(r.put.bind(r, i, s)) }, count(s) { let i = o.transaction(t, "readonly").objectStore(t); return n(i.count.bind(i, s)) }, remove(s) { let i = o.transaction(t, "readwrite").objectStore(t); return n(i.delete.bind(i, s)) }, clear() { let s = o.transaction(t, "readwrite").objectStore(t); return n(s.clear.bind(s)) }, txn(s) { return o.transaction(t, s) } } } async function qt(e) { let t = (e == null ? void 0 : e.db) || `${e.store}--db`; return new Promise((o, n) => { var s; let i = window.indexedDB.open(t, (s = e == null ? void 0 : e.version) !== null && s !== void 0 ? s : 1); i.onsuccess = r => o(r.target.result), i.onerror = r => n(r.target.result), i.onupgradeneeded = r => { var c; let l = r.target.result, d = r.target.transaction, p = l.objectStoreNames.contains(e.store) ? d.objectStore(e.store) : l.createObjectStore(e.store); (c = e.upgrade) === null || c === void 0 || c.call(e, r, p) } }) } var Y = class { constructor() { this.listenerMap = new Map; this.vocab = [] } get listeners() { return [...this.listenerMap.values()].reverse() } }, pt, mt, ht = (mt = (pt = window.LichessVoicePlugin) == null ? void 0 : pt.mic) != null ? mt : new class { constructor() { this.language = "en"; this.voskStatus = ""; this.busy = !1; this.interrupt = !1; this.paused = 0; window.LichessVoicePlugin = { mic: this, vosk: void 0 }, lichess.mic = this, this.recs = { full: new Y, partial: new Y } } get lang() { return this.language } get vosk() { var e; return (e = window.LichessVoicePlugin) == null ? void 0 : e.vosk } addListener(e, t, o = "full") { this.recs[o].listenerMap.set(e, t) } removeListener(e) { Object.values(this.recs).forEach(t => t.listenerMap.delete(e)) } setLang(e) { e !== this.language && (this.stop(), this.language = e) } setVocabulary(e, t = "full") { var n, s; let o = this.recs[t]; e.length === o.vocab.length && e.every((i, r) => i === o.vocab[r]) || (o.vocab = e, (n = o.node) == null || n.disconnect(), o.node = void 0, (s = this.vosk) != null && s.isReady(this.lang) && this.initKaldi(t)) } useGrammar(e) { return Ne(lichess.assetUrl(`compiled/grammar/${e}.json`)) } stop() { var e, t; this.micTrack && (this.micTrack.enabled = !1), (e = this.vosk) == null || e.stop(), (t = this.download) == null || t.abort(), this.download || this.broadcast("", "stop"), this.download = void 0 } async start() { let [e, t] = ["Unknown", "error"]; try { if (this.isListening) return; this.busy = !0, await this.initModel(), this.recs.full.node || this.initKaldi("full"), this.recs.partial.node || this.initKaldi("partial"), this.micTrack.enabled = !0, this.mode = "full", [e, t] = ["Listening...", "start"] } catch (o) { throw this.stop(), console.log(o), [e, t] = [o.toString(), "error"], o } finally { this.busy = !1, this.broadcast(e, t, 4e3) } } pause() { var e; ++this.paused !== 1 || !((e = this.micTrack) != null && e.enabled) || (this.micTrack.enabled = !1, this.broadcast("Paused...", "status")) } resume() { var e; this.paused = Math.min(this.paused - 1, 0), !(this.paused !== 0 || ((e = this.micTrack) == null ? void 0 : e.enabled) === void 0) && (this.micTrack.enabled = !0, this.broadcast("Listening...", "status")) } initKaldi(e) { var t; this.recs[e].node = (t = this.vosk) == null ? void 0 : t.setRecognizer({ mode: e, audioCtx: this.audioCtx, vocab: this.recs[e].vocab, broadcast: this.broadcast.bind(this) }) } async initModel() { var n; if ((n = this.vosk) != null && n.isReady(this.lang)) return; this.broadcast("Loading..."); let e = lichess.assetUrl(ut.get(this.lang), { noVersion: !0 }), t = this.downloadModel(`/vosk/${e.replace(/[\W]/g, "_")}`), o = this.initAudio(); await lichess.loadModule("voice.vosk"), await t, await this.vosk.initModel(e, this.lang), await o } async initAudio() { this.audioCtx || (this.audioCtx = new AudioContext, this.mediaStream = await navigator.mediaDevices.getUserMedia({ video: !1, audio: { sampleRate: this.audioCtx.sampleRate, echoCancellation: !0, noiseSuppression: !0 } }), this.micSource = this.audioCtx.createMediaStreamSource(this.mediaStream)) } set mode(e) { var t, o; this.recs[e] && ((o = (t = this.recs[this.listenMode]) == null ? void 0 : t.node) == null || o.disconnect(), this.micSource.disconnect(), this.micSource.connect(this.recs[e].node), this.recs[e].node.connect(this.audioCtx.destination), this.vosk.setMode(e), this.listenMode = e) } get mode() { return this.listenMode } get isBusy() { return this.busy } get status() { return this.voskStatus } get isListening() { var e; return this.paused === 0 && !this.busy && ((e = this.micTrack) == null ? void 0 : e.enabled) === !0 } get micTrack() { var e; return (e = this.mediaStream) == null ? void 0 : e.getAudioTracks()[0] } broadcast(e, t = "status", o = 0) { if (t === "partial") { for (let n of this.recs.partial.listeners) n(e, t); return } window.clearTimeout(this.broadcastTimeout), this.voskStatus = e; for (let n of this.recs.full.listeners) this.interrupt || n(e, t); this.interrupt = !1, this.broadcastTimeout = o > 0 ? window.setTimeout(() => this.broadcast(""), o) : void 0 } stopPropagation() { this.interrupt = !0 } async downloadModel(e) { let t = await dt({ db: "/vosk", store: "FILE_DATA", version: 21, upgrade: (s, i) => { i == null || i.createIndex("timestamp", "timestamp", { unique: !1 }) } }); if (await t.count(`${e}/extracted.ok`) > 0) return; let o = await new Promise((s, i) => { this.download = new XMLHttpRequest, this.download.open("GET", lichess.assetUrl(ut.get(this.lang)), !0), this.download.responseType = "arraybuffer", this.download.onerror = r => i("Failed. See console"), this.download.onabort = r => i("Aborted"), this.download.onprogress = r => this.broadcast(r.total <= 0 ? "Downloading..." : `Downloaded ${Math.round(100 * r.loaded / r.total)}% of ${Math.round(r.total / 1e6)}MB`), this.download.onload = r => { var c, l, d; ((c = this.download) == null ? void 0 : c.status) !== 200 ? i(`${(l = this.download) == null ? void 0 : l.status} Failed`) : s((d = this.download) == null ? void 0 : d.response) }, this.download.send() }); this.broadcast("Extracting..."); let n = new Date; await t.put(e, { timestamp: n, mode: 16877 }), await t.put(`${e}/downloaded.ok`, { contents: new Uint8Array([]), timestamp: n, mode: 33206 }), await t.remove(`${e}/downloaded.tar.gz`), await t.put(`${e}/downloaded.tar.gz`, { contents: new Uint8Array(o), timestamp: n, mode: 33188 }), t.txn("readwrite").objectStore("FILE_DATA").index("timestamp") } }, ut = new Map([["ca", "lifat/vosk/model-ca-0.4.tar.gz"], ["cn", "lifat/vosk/model-cn-0.22.tar.gz"], ["cs", "lifat/vosk/model-cs-0.4.tar.gz"], ["de", "lifat/vosk/model-de-0.15.tar.gz"], ["en", "lifat/vosk/model-en-us-0.15.tar.gz"], ["eo", "lifat/vosk/model-eo-0.42.tar.gz"], ["es", "lifat/vosk/model-es-0.42.tar.gz"], ["fa", "lifat/vosk/model-fa-0.4.tar.gz"], ["fr", "lifat/vosk/model-fr-0.22.tar.gz"], ["hi", "lifat/vosk/model-hi-0.22.tar.gz"], ["it", "lifat/vosk/model-it-0.22.tar.gz"], ["ja", "lifat/vosk/model-ja-0.22.tar.gz"], ["ko", "lifat/vosk/model-ko-0.22.tar.gz"], ["kz", "lifat/vosk/model-kz-0.15.tar.gz"], ["nl", "lifat/vosk/model-nl-0.22.tar.gz"], ["pl", "lifat/vosk/model-pl-0.22.tar.gz"], ["pt", "lifat/vosk/model-pt-0.3.tar.gz"], ["ru", "lifat/vosk/model-ru-0.22.tar.gz"], ["tr", "lifat/vosk/model-tr-0.3.tar.gz"], ["uk", "lifat/vosk/model-uk-v3.tar.gz"], ["uz", "lifat/vosk/model-uz-0.22.tar.gz"], ["vi", "lifat/vosk/model-vi-0.4.tar.gz"]]); var ke, Vt = e => e.includes(" ") ? e.split(" ")[1] : e; function _(e) { let t = $(e); if (t.data("watched")) return; t.data("watched", 1); let o = $('<div class="chat__members__inner">').appendTo(t), n = $(`<div class="chat__members__number" data-icon="${Pe}" title="Spectators"></div>`).appendTo(o), s = $("<div>").appendTo(o); lichess.pubsub.on("socket.in.crowd", r => i(r.watchers || r)); let i = r => { if (ke = r, !r || !r.nb) { t.addClass("none"); return } if (n.text("" + r.nb), r.users) { let c = r.users.map(l => l || "").join(";"); if (s.data("prevUsers") !== c) { s.data("prevUsers", c); let l = r.users.map(d => d ? `<a class="user-link ulpt" href="/@/${Vt(d)}">${d}</a>` : "Anonymous"); r.anons === 1 ? l.push("Anonymous") : r.anons && l.push(`Anonymous (${r.anons})`), s.html(l.join(", ")) } } else s.html(""); t.removeClass("none") }; ke && i(ke) } var ft = () => { let e = window.lichess; e.StrongSocket = h, e.requestIdleCallback = T, e.sri = x, e.storage = m, e.tempStorage = We, e.once = D, e.powertip = K, e.clockWidget = E, e.spinnerHtml = st, e.assetUrl = v, e.loadCss = z, e.loadCssPath = g, e.jsModule = I, e.loadScript = W, e.loadModule = w, e.loadIife = ot, e.hopscotch = nt, e.userComplete = G, e.makeChat = ve, e.idleTimer = P, e.pubsub = u, e.unload = re, e.redirect = Ve, e.reload = y, e.watchers = _, e.escapeHtml = q, e.announce = H, e.trans = ue, e.sound = lt, e.mic = ht, e.miniBoard = F, e.miniGame = j, e.timeago = Ze, e.dateFormat = pe, e.contentLoaded = t => u.emit("content-loaded", t) }; console.info("Lichess is open source! https://lichess.org/source"); var zt = a, gt = zt; var O = class { constructor(t) { this.el = t; this.loaded = !1; this.receive = (t, o) => { this.users.clear(), t.forEach(this.insert), o.playing.map(n => this.users.get(n)).filter(ie).forEach(n => n.playing = !0), o.patrons.map(n => this.users.get(n)).filter(ie).forEach(n => n.patron = !0), this.repaint() }; this.repaint = () => { this.loaded && requestAnimationFrame(() => { var o; let t = Array.from(this.users.keys()).sort(); this.titleEl.innerHTML = k.pluralSame("nbFriendsOnline", t.length, this.loaded ? `<strong>${t.length}</strong>` : "-"), (o = this.el.querySelector(".nobody")) == null || o.classList.toggle("none", !!t[0]), this.el.querySelector(".list").innerHTML = t.map(n => this.renderFriend(this.users.get(n))).join("") }) }; this.renderFriend = t => { let o = `<i class="line${t.patron ? " patron" : ""}"></i>`, n = t.title ? `<span class="utitle"${t.title === "BOT" ? " data-bot" : ""}>${t.title}</span>&nbsp;` : "", s = "/@/" + t.name, i = t.playing ? `<a data-icon="${N}" class="tv ulpt" data-pt-pos="nw" href="${s}/tv" data-href="${s}"></a>` : ""; return `<div><a class="user-link ulpt" data-pt-pos="nw" href="${s}">${o}${n}${t.name}</a>${i}</div>` }; this.enters = (t, o) => { let n = this.insert(t); n.playing = o.playing, n.patron = o.patron, this.repaint() }; this.leaves = t => { this.users.delete(this.getId(t)), this.repaint() }; this.playing = t => { this.insert(t).playing = !0, this.repaint() }; this.stopped_playing = t => { this.insert(t).playing = !1, this.repaint() }; this.insert = t => { let o = this.getId(t); return this.users.has(o) || this.users.set(o, this.toFriend(t)), this.users.get(o) }; this.getId = t => t.toLowerCase().replace(/^\w+\s/, ""); this.toFriend = t => { let o = t.split(" "); return { id: o[o.length - 1].toLowerCase(), name: o[o.length - 1], title: o.length > 1 ? o[0] : void 0, playing: !1, patron: !1 } }; this.titleEl = this.el.querySelector(".friend_box_title"), this.titleEl.addEventListener("click", () => { var o; (o = this.el.querySelector(".content_wrap")) == null || o.classList.toggle("none"), this.loaded || (this.loaded = !0, u.emit("socket.send", "following_onlines")) }), this.users = new Map, u.on("socket.in.following_onlines", this.receive), ["enters", "leaves", "playing", "stopped_playing"].forEach(o => u.on("socket.in.following_" + o, this[o])) } }; async function bt() { var i; if (!("serviceWorker" in navigator && "Notification" in window && "PushManager" in window)) return; let e = new URL(v(I("serviceWorker"), { sameDomain: !0 }), self.location.href); e.searchParams.set("asset-url", document.body.getAttribute("data-asset-url")), document.body.getAttribute("data-dev") && e.searchParams.set("dev", "1"); let t = document.body.getAttribute("data-dev") ? "none" : "all" } var vt = () => { if (!lichess.dasher) { let t = $("#dasher_app").html(`<div class="initiating">${lichess.spinnerHtml}</div>`).empty()[0], o = $("#top .dasher")[0]; lichess.dasher = lichess.loadModule("dasher").then(() => window.LichessDasher(t, o)) } return lichess.dasher }; function wt() { let e = `<div class="initiating">${lichess.spinnerHtml}</div>`, t = o => { let n = document.querySelector(o), s = n && window.getComputedStyle(n).display; return s && s != "none" }; "ontouchstart" in window && !window.matchMedia("(max-width: 979px)").matches && $("#topnav > section > a").removeAttr("href"), $("#topnav-toggle").on("change", o => document.body.classList.toggle("masked", o.target.checked)), $("#top").on("click", "a.toggle", function () { let o = $(this).parent().toggleClass("shown"); return o.siblings(".shown").removeClass("shown"), setTimeout(() => { let n = s => { var i; (i = o[0]) != null && i.contains(s.target) || (o.removeClass("shown"), $("html").off("click", n)) }; $("html").on("click", n) }, 10), !1 }); { let o, n, s = $("#challenge-toggle"); s.one("mouseover click", () => i()); let i = function (r) { if (n) return; n = !0; let c = $("#challenge-app").html(e); g("challenge"), w("challenge").then(() => o = window.LichessChallenge(c[0], { data: r, show() { t("#challenge-app") || s.trigger("click") }, setCount(l) { s.find("span").data("count", l) }, pulse() { s.addClass("pulse") } })) }; u.on("socket.in.challenges", r => { o ? o.update(r) : i(r) }), u.on("challenge-app.open", () => s.trigger("click")) } { let o, n, s = $("#notify-toggle"), i = "#notify-app", r = c => { if (n) return; n = !0; let l = $("#notify-app").html(e); g("notify"), w("notify").then(() => { o = window.LichessNotify(l.empty()[0], { data: c, isVisible: () => t(i), updateUnread(d) { let p = s.find("span").data("count") || 0; return d == "increment" && (d = p + 1), s.find("span").data("count", this.isVisible() ? 0 : d), d && d != p }, show() { t(i) || s.trigger("click") }, setNotified() { lichess.socket.send("notified") }, pulse() { s.addClass("pulse") } }) }) }; s.one("mouseover click", () => r()).on("click", () => { "Notification" in window && Notification.requestPermission(), setTimeout(() => { o && t(i) && o.onShow() }, 200) }), u.on("socket.in.notifications", c => { o ? o.update(c) : r(c) }), u.on("notify-app.set-read", c => { o ? o.setMsgRead(c) : r() }) } $("#top .dasher .toggle").one("mouseover click", function () { $(this).removeAttr("href"), g("dasher"), vt() }); { let o = $("#clinput"); if (!o.length) return; let n = o.find("input"), s = !1, i = () => { s || (s = !0, w("cli").then(() => window.LichessCli.app(n[0]), () => s = !1)) }; n.on({ blur() { n.val(""), $("body").removeClass("clinput") }, focus() { i(), $("body").addClass("clinput") } }), o.find("a").on({ mouseover: i, click() { $("body").hasClass("clinput") ? n[0].blur() : n[0].focus() } }), window.Mousetrap.bind("/", () => { n.val("/"), n[0].focus() }).bind("s", () => n[0].focus()) } } var xt = "modal-overlay"; function f(e) { f.close(); let t = $(`<div id="modal-wrap"><span class="close" role="button" aria-label="Close" data-icon="${Me}" tabindex="0"></span></div>`), o = $(`<div id="${xt}" class="${e.class}">`); return e.noClickAway || o.on("click", f.close), $('<a href="#"></a>').appendTo(o), t.appendTo(o), $('<a href="#"></a>').appendTo(o), e.content.clone().removeClass("none").appendTo(t), e.onInsert && e.onInsert(t), f.onClose = e.onClose, t.find(".close,.cancel").each(function () { Wt(this, f.close) }), $("body").addClass("overlayed").prepend(o), Gt(t), t } f.close = () => { $("body").removeClass("overlayed"), $(`#${xt}`).each(function () { f.onClose && f.onClose(), $(this).remove() }), delete f.onClose }; f.onClose = void 0; var Wt = (e, t) => { e.addEventListener("click", t), e.addEventListener("keydown", o => o.code === "Enter" || o.code === "Space" ? t() : !0) }, Gt = e => { e.on("click", t => t.stopPropagation()), Kt(e) }, yt = 'button:not(:disabled), [href], input:not(:disabled):not([type="hidden"]), select:not(:disabled), textarea:not(:disabled), [tabindex="0"]'; function kt(e) { var t; let o = $("#modal-wrap")[0]; if (!o) return; let n = o.compareDocumentPosition(e.target); if (n & Node.DOCUMENT_POSITION_CONTAINED_BY) return; let s = $(o).find(yt), i = n & Node.DOCUMENT_POSITION_FOLLOWING ? 0 : s.length - 1; (t = s.get(i)) === null || t === void 0 || t.focus(), e.preventDefault() } var Kt = e => { let t = e.find(yt); setTimeout(() => { var o, n; return (n = (o = t[1]) !== null && o !== void 0 ? o : t[0]) === null || n === void 0 ? void 0 : n.focus() }) }; ft(); lichess.info = gt; lichess.load.then(() => { $("#user_tag").removeAttr("href"), requestAnimationFrame(() => { B(), R(), u.on("content-loaded", B), u.on("content-loaded", R), he(1e3), u.on("content-loaded", me) }), T(() => { let e = document.getElementById("friend_box"); e && new O(e); let t = document.querySelector(".chat__members"); if (t && _(t), $("#main-wrap").on("click", ".autoselect", function () { this.select() }).on("click", "button.copy", function () { let n = () => $(this).attr("data-icon", Se); return $("#" + $(this).data("rel")).each(function () { try { navigator.clipboard.writeText(this.value).then(n) } catch (s) { console.error(s) } }), !1 }), $("body").on("click", "a.relation-button", function () { let n = $(this).addClass("processing").css("opacity", .3); return b(this.href, { method: "post" }).then(s => { s.includes("relation-actions") ? n.parent().replaceWith(s) : n.replaceWith(s) }), !1 }), $(".mselect .button").on("click", function () { let n = $(this).parent(); n.toggleClass("shown"), T(() => { let s = i => { n[0].contains(i.target) || (n.removeClass("shown"), $("html").off("click", s)) }; $("html").on("click", s) }, 200) }), K.watchMouse(), setTimeout(() => { lichess.socket || (lichess.socket = new h("/socket/v5", !1)) }, 300), wt(), window.addEventListener("resize", () => document.body.dispatchEvent(new Event("chessground.resize"))), $(".user-autocomplete").each(function () { let n = !!this.autofocus, s = () => G().then(i => i({ input: this, friend: $(this).data("friend"), tag: $(this).data("tag"), focus: n })); n ? s() : $(this).one("focus", s) }), window.InfiniteScroll && window.InfiniteScroll(".infinite-scroll"), $("input.confirm, button.confirm").on("click", function () { return confirm(this.title || "Confirm this action?") }), $("#main-wrap").on("click", "a.bookmark", function () { let n = $(this).toggleClass("bookmarked"); b(this.href, { method: "post" }); let s = (parseInt(n.text(), 10) || 0) + (n.hasClass("bookmarked") ? 1 : -1); return n.find("span").html("" + (s > 0 ? s : "")), !1 }), $("body").on("focusin", kt), window.Mousetrap.bind("esc", () => { let n = $("#modal-wrap .close"); if (n.length) n.trigger("click"); else { let s = $(":focus"); s.length && s.trigger("blur") } }), navigator.userAgent.includes("Edge/") && setTimeout(() => { let n = document.getElementById("piece-sprite"); n.href = n.href.replace(".css", ".external.css") }, 1e3), J() && !("MSStream" in window)) { let n = document.querySelector("meta[name=viewport]"); n.setAttribute("content", n.getAttribute("content") + ",maximum-scale=1.0") } location.hash === "#blind" && !$("body").hasClass("blind-mode") && b("/toggle-blind-mode", { method: "post", body: Be({ enable: 1, redirect: "/" }) }).then(y); let o = document.body.getAttribute("data-announce"); o && H(JSON.parse(o)), et(), bt(), u.on("socket.in.redirect", n => { lichess.unload.expected = !0, lichess.redirect(n) }), u.on("socket.in.fen", n => document.querySelectorAll(".mini-game-" + n.id).forEach(s => le(s, n))), u.on("socket.in.finish", n => document.querySelectorAll(".mini-game-" + n.id).forEach(s => de(s, n.win))), u.on("socket.in.announce", H), u.on("socket.in.tournamentReminder", n => { if ($("#announce").length || $("body").data("tournament-id") == n.id) return; let s = "/tournament/" + n.id; $("body").append($('<div id="announce">').append($(`<a data-icon="${Ae}" class="text">`).attr("href", s).text(n.name)).append($('<div class="actions">').append($(`<a class="withdraw text" data-icon="${Le}">`).attr("href", s + "/withdraw").text(k("pause")).on("click", function () { return b(this.href, { method: "post" }), $("#announce").remove(), !1 })).append($(`<a class="text" data-icon="${$e}">`).attr("href", s).text(k("resume"))))) }) }, 800) });
})();
export var LichessEditor = function () { "use strict"; const e = { createElement: function (e, t) { return document.createElement(e, t) }, createElementNS: function (e, t, n) { return document.createElementNS(e, t, n) }, createTextNode: function (e) { return document.createTextNode(e) }, createComment: function (e) { return document.createComment(e) }, insertBefore: function (e, t, n) { e.insertBefore(t, n) }, removeChild: function (e, t) { e.removeChild(t) }, appendChild: function (e, t) { e.appendChild(t) }, parentNode: function (e) { return e.parentNode }, nextSibling: function (e) { return e.nextSibling }, tagName: function (e) { return e.tagName }, setTextContent: function (e, t) { e.textContent = t }, getTextContent: function (e) { return e.textContent }, isElement: function (e) { return 1 === e.nodeType }, isText: function (e) { return 3 === e.nodeType }, isComment: function (e) { return 8 === e.nodeType } }; function t(e, t, n, r, o) { return { sel: e, data: t, children: n, text: r, elm: o, key: void 0 === t ? void 0 : t.key } } const n = Array.isArray; function r(e) { return "string" == typeof e || "number" == typeof e || e instanceof String || e instanceof Number } function o(e) { return void 0 === e } function s(e) { return void 0 !== e } const i = t("", {}, [], void 0, void 0); function a(e, t) { var n, r; const o = e.key === t.key, s = (null === (n = e.data) || void 0 === n ? void 0 : n.is) === (null === (r = t.data) || void 0 === r ? void 0 : r.is); return e.sel === t.sel && o && s } function c(e, t, n) { var r; const o = {}; for (let s = t; s <= n; ++s) { const t = null === (r = e[s]) || void 0 === r ? void 0 : r.key; void 0 !== t && (o[t] = s) } return o } const u = ["create", "update", "remove", "destroy", "pre", "post"]; function h(e, t, n) { if (e.ns = "http://www.w3.org/2000/svg", "foreignObject" !== n && void 0 !== t) for (let r = 0; r < t.length; ++r) { const e = t[r].data; void 0 !== e && h(e, t[r].children, t[r].sel) } } function l(e, o, s) { let i, a, c, u = {}; if (void 0 !== s ? (null !== o && (u = o), n(s) ? i = s : r(s) ? a = s.toString() : s && s.sel && (i = [s])) : null != o && (n(o) ? i = o : r(o) ? a = o.toString() : o && o.sel ? i = [o] : u = o), void 0 !== i) for (c = 0; c < i.length; ++c)r(i[c]) && (i[c] = t(void 0, void 0, void 0, i[c], void 0)); return "s" !== e[0] || "v" !== e[1] || "g" !== e[2] || 3 !== e.length && "." !== e[3] && "#" !== e[3] || h(u, i, e), t(e, u, i, a, void 0) } function d(e, t) { let n; const r = t.elm; let o = e.data.attrs, s = t.data.attrs; if ((o || s) && o !== s) { for (n in o = o || {}, s = s || {}, s) { const e = s[n]; o[n] !== e && (!0 === e ? r.setAttribute(n, "") : !1 === e ? r.removeAttribute(n) : 120 !== n.charCodeAt(0) ? r.setAttribute(n, e) : 58 === n.charCodeAt(3) ? r.setAttributeNS("http://www.w3.org/XML/1998/namespace", n, e) : 58 === n.charCodeAt(5) ? r.setAttributeNS("http://www.w3.org/1999/xlink", n, e) : r.setAttribute(n, e)) } for (n in o) n in s || r.removeAttribute(n) } } const p = { create: d, update: d }; function f(e, t) { let n, r; const o = t.elm; let s = e.data.class, i = t.data.class; if ((s || i) && s !== i) { for (r in s = s || {}, i = i || {}, s) s[r] && !Object.prototype.hasOwnProperty.call(i, r) && o.classList.remove(r); for (r in i) n = i[r], n !== s[r] && o.classList[n ? "add" : "remove"](r) } } const m = { create: f, update: f }; function g(e, t, n) { if ("function" == typeof e) e.call(t, n, t); else if ("object" == typeof e) for (let r = 0; r < e.length; r++)g(e[r], t, n) } function b(e, t) { const n = e.type, r = t.data.on; r && r[n] && g(r[n], t, e) } function v(e, t) { const n = e.data.on, r = e.listener, o = e.elm, s = t && t.data.on, i = t && t.elm; let a; if (n !== s) { if (n && r) if (s) for (a in n) s[a] || o.removeEventListener(a, r, !1); else for (a in n) o.removeEventListener(a, r, !1); if (s) { const r = t.listener = e.listener || function e(t) { b(t, e.vnode) }; if (r.vnode = t, n) for (a in s) n[a] || i.addEventListener(a, r, !1); else for (a in s) i.addEventListener(a, r, !1) } } } const k = { create: v, update: v, destroy: v }; function w(e, t) { let n, r, o; const s = t.elm; let i = e.data.props, a = t.data.props; if ((i || a) && i !== a) for (n in i = i || {}, a = a || {}, a) r = a[n], o = i[n], o === r || "value" === n && s[n] === r || (s[n] = r) } const y = { create: w, update: w }, C = ["K", "Q", "k", "q"], S = ["a", "b", "c", "d", "e", "f", "g", "h"], E = ["1", "2", "3", "4", "5", "6", "7", "8"], q = ["white", "black"], x = ["pawn", "knight", "bishop", "rook", "queen", "king"], M = ["a", "h"]; function P(e) { return "role" in e } function A(e) { return e = (858993459 & (e -= e >>> 1 & 1431655765)) + (e >>> 2 & 858993459), Math.imul(e + (e >>> 4) & 252645135, 16843009) >> 24 } function R(e) { return (e = e >>> 8 & 16711935 | (16711935 & e) << 8) >>> 16 & 65535 | (65535 & e) << 16 } function O(e) { return R(e = (e = (e = e >>> 1 & 1431655765 | (1431655765 & e) << 1) >>> 2 & 858993459 | (858993459 & e) << 2) >>> 4 & 252645135 | (252645135 & e) << 4) } class T { constructor(e, t) { this.lo = e, this.hi = t, this.lo = 0 | e, this.hi = 0 | t } static fromSquare(e) { return e >= 32 ? new T(0, 1 << e - 32) : new T(1 << e, 0) } static fromRank(e) { return new T(255, 0).shl64(8 * e) } static fromFile(e) { return new T(16843009 << e, 16843009 << e) } static empty() { return new T(0, 0) } static full() { return new T(4294967295, 4294967295) } static corners() { return new T(129, 2164260864) } static center() { return new T(402653184, 24) } static backranks() { return new T(255, 4278190080) } static backrank(e) { return "white" === e ? new T(255, 0) : new T(0, 4278190080) } static lightSquares() { return new T(1437226410, 1437226410) } static darkSquares() { return new T(2857740885, 2857740885) } complement() { return new T(~this.lo, ~this.hi) } xor(e) { return new T(this.lo ^ e.lo, this.hi ^ e.hi) } union(e) { return new T(this.lo | e.lo, this.hi | e.hi) } intersect(e) { return new T(this.lo & e.lo, this.hi & e.hi) } diff(e) { return new T(this.lo & ~e.lo, this.hi & ~e.hi) } intersects(e) { return this.intersect(e).nonEmpty() } isDisjoint(e) { return this.intersect(e).isEmpty() } supersetOf(e) { return e.diff(this).isEmpty() } subsetOf(e) { return this.diff(e).isEmpty() } shr64(e) { return e >= 64 ? T.empty() : e >= 32 ? new T(this.hi >>> e - 32, 0) : e > 0 ? new T(this.lo >>> e ^ this.hi << 32 - e, this.hi >>> e) : this } shl64(e) { return e >= 64 ? T.empty() : e >= 32 ? new T(0, this.lo << e - 32) : e > 0 ? new T(this.lo << e, this.hi << e ^ this.lo >>> 32 - e) : this } bswap64() { return new T(R(this.hi), R(this.lo)) } rbit64() { return new T(O(this.hi), O(this.lo)) } minus64(e) { const t = this.lo - e.lo, n = (t & e.lo & 1) + (e.lo >>> 1) + (t >>> 1) >>> 31; return new T(t, this.hi - (e.hi + n)) } equals(e) { return this.lo === e.lo && this.hi === e.hi } size() { return A(this.lo) + A(this.hi) } isEmpty() { return 0 === this.lo && 0 === this.hi } nonEmpty() { return 0 !== this.lo || 0 !== this.hi } has(e) { return 0 != (e >= 32 ? this.hi & 1 << e - 32 : this.lo & 1 << e) } set(e, t) { return t ? this.with(e) : this.without(e) } with(e) { return e >= 32 ? new T(this.lo, this.hi | 1 << e - 32) : new T(this.lo | 1 << e, this.hi) } without(e) { return e >= 32 ? new T(this.lo, this.hi & ~(1 << e - 32)) : new T(this.lo & ~(1 << e), this.hi) } toggle(e) { return e >= 32 ? new T(this.lo, this.hi ^ 1 << e - 32) : new T(this.lo ^ 1 << e, this.hi) } last() { return 0 !== this.hi ? 63 - Math.clz32(this.hi) : 0 !== this.lo ? 31 - Math.clz32(this.lo) : void 0 } first() { return 0 !== this.lo ? 31 - Math.clz32(this.lo & -this.lo) : 0 !== this.hi ? 63 - Math.clz32(this.hi & -this.hi) : void 0 } withoutFirst() { return 0 !== this.lo ? new T(this.lo & this.lo - 1, this.hi) : new T(0, this.hi & this.hi - 1) } moreThanOne() { return 0 !== this.hi && 0 !== this.lo || 0 != (this.lo & this.lo - 1) || 0 != (this.hi & this.hi - 1) } singleSquare() { return this.moreThanOne() ? void 0 : this.last() } isSingleSquare() { return this.nonEmpty() && !this.moreThanOne() } *[Symbol.iterator]() { let e = this.lo, t = this.hi; for (; 0 !== e;) { const t = 31 - Math.clz32(e & -e); e ^= 1 << t, yield t } for (; 0 !== t;) { const e = 31 - Math.clz32(t & -t); t ^= 1 << e, yield 32 + e } } *reversed() { let e = this.lo, t = this.hi; for (; 0 !== t;) { const e = 31 - Math.clz32(t); t ^= 1 << e, yield 32 + e } for (; 0 !== e;) { const t = 31 - Math.clz32(e); e ^= 1 << t, yield t } } } class K { constructor() { } static default() { const e = new K; return e.reset(), e } static racingKings() { const e = new K; return e.occupied = new T(65535, 0), e.promoted = T.empty(), e.white = new T(61680, 0), e.black = new T(3855, 0), e.pawn = T.empty(), e.knight = new T(6168, 0), e.bishop = new T(9252, 0), e.rook = new T(16962, 0), e.queen = new T(129, 0), e.king = new T(33024, 0), e } static horde() { const e = new K; return e.occupied = new T(4294967295, 4294901862), e.promoted = T.empty(), e.white = new T(4294967295, 102), e.black = new T(0, 4294901760), e.pawn = new T(4294967295, 16711782), e.knight = new T(0, 1107296256), e.bishop = new T(0, 603979776), e.rook = new T(0, 2164260864), e.queen = new T(0, 134217728), e.king = new T(0, 268435456), e } reset() { this.occupied = new T(65535, 4294901760), this.promoted = T.empty(), this.white = new T(65535, 0), this.black = new T(0, 4294901760), this.pawn = new T(65280, 16711680), this.knight = new T(66, 1107296256), this.bishop = new T(36, 603979776), this.rook = new T(129, 2164260864), this.queen = new T(8, 134217728), this.king = new T(16, 268435456) } static empty() { const e = new K; return e.clear(), e } clear() { this.occupied = T.empty(), this.promoted = T.empty(); for (const e of q) this[e] = T.empty(); for (const e of x) this[e] = T.empty() } clone() { const e = new K; e.occupied = this.occupied, e.promoted = this.promoted; for (const t of q) e[t] = this[t]; for (const t of x) e[t] = this[t]; return e } equalsIgnorePromoted(e) { return !!this.white.equals(e.white) && x.every((t => this[t].equals(e[t]))) } equals(e) { return this.equalsIgnorePromoted(e) && this.promoted.equals(e.promoted) } getColor(e) { return this.white.has(e) ? "white" : this.black.has(e) ? "black" : void 0 } getRole(e) { for (const t of x) if (this[t].has(e)) return t } get(e) { const t = this.getColor(e); if (!t) return; return { color: t, role: this.getRole(e), promoted: this.promoted.has(e) } } take(e) { const t = this.get(e); return t && (this.occupied = this.occupied.without(e), this[t.color] = this[t.color].without(e), this[t.role] = this[t.role].without(e), t.promoted && (this.promoted = this.promoted.without(e))), t } set(e, t) { const n = this.take(e); return this.occupied = this.occupied.with(e), this[t.color] = this[t.color].with(e), this[t.role] = this[t.role].with(e), t.promoted && (this.promoted = this.promoted.with(e)), n } has(e) { return this.occupied.has(e) } *[Symbol.iterator]() { for (const e of this.occupied) yield [e, this.get(e)] } pieces(e, t) { return this[e].intersect(this[t]) } rooksAndQueens() { return this.rook.union(this.queen) } bishopsAndQueens() { return this.bishop.union(this.queen) } kingOf(e) { return this.king.intersect(this[e]).diff(this.promoted).singleSquare() } } class F { constructor() { } static empty() { const e = new F; for (const t of x) e[t] = 0; return e } static fromBoard(e, t) { const n = new F; for (const r of x) n[r] = e.pieces(t, r).size(); return n } clone() { const e = new F; for (const t of x) e[t] = this[t]; return e } equals(e) { return x.every((t => this[t] === e[t])) } add(e) { const t = new F; for (const n of x) t[n] = this[n] + e[n]; return t } nonEmpty() { return x.some((e => this[e] > 0)) } isEmpty() { return !this.nonEmpty() } hasPawns() { return this.pawn > 0 } hasNonPawns() { return this.knight > 0 || this.bishop > 0 || this.rook > 0 || this.queen > 0 || this.king > 0 } count() { return this.pawn + this.knight + this.bishop + this.rook + this.queen + this.king } } class N { constructor(e, t) { this.white = e, this.black = t } static empty() { return new N(F.empty(), F.empty()) } static fromBoard(e) { return new N(F.fromBoard(e, "white"), F.fromBoard(e, "black")) } clone() { return new N(this.white.clone(), this.black.clone()) } equals(e) { return this.white.equals(e.white) && this.black.equals(e.black) } add(e) { return new N(this.white.add(e.white), this.black.add(e.black)) } count() { return this.white.count() + this.black.count() } isEmpty() { return this.white.isEmpty() && this.black.isEmpty() } nonEmpty() { return !this.isEmpty() } hasPawns() { return this.white.hasPawns() || this.black.hasPawns() } hasNonPawns() { return this.white.hasNonPawns() || this.black.hasNonPawns() } } class I { constructor(e, t) { this.white = e, this.black = t } static default() { return new I(3, 3) } clone() { return new I(this.white, this.black) } equals(e) { return this.white === e.white && this.black === e.black } } function L(e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t } var B, D = function () { function e() { } var t = e.prototype; return t.unwrap = function (e, t) { var n = this._chain((function (t) { return B.ok(e ? e(t) : t) }), (function (e) { return t ? B.ok(t(e)) : B.err(e) })); if (n.isErr) throw n.error; return n.value }, t.map = function (e, t) { return this._chain((function (t) { return B.ok(e(t)) }), (function (e) { return B.err(t ? t(e) : e) })) }, t.chain = function (e, t) { return this._chain(e, t || function (e) { return B.err(e) }) }, e }(), z = function (e) { function t(t) { var n; return (n = e.call(this) || this).value = t, n.isOk = !0, n.isErr = !1, n } return L(t, e), t.prototype._chain = function (e, t) { return e(this.value) }, t }(D), _ = function (e) { function t(t) { var n; return (n = e.call(this) || this).error = t, n.isOk = !1, n.isErr = !0, n } return L(t, e), t.prototype._chain = function (e, t) { return t(this.error) }, t }(D); function V(e) { return void 0 !== e } function j(e) { return "white" === e ? "black" : "white" } function H(e) { return e >> 3 } function Q(e) { return 7 & e } function W(e) { switch (e) { case "pawn": return "p"; case "knight": return "n"; case "bishop": return "b"; case "rook": return "r"; case "queen": return "q"; case "king": return "k" } } function U(e, t) { return "white" === e ? "a" === t ? 2 : 6 : "a" === t ? 58 : 62 } function X(e, t) { let n = T.empty(); for (const r of t) { const t = e + r; 0 <= t && t < 64 && Math.abs(Q(e) - Q(t)) <= 2 && (n = n.with(t)) } return n } function Y(e) { const t = []; for (let n = 0; n < 64; n++)t[n] = e(n); return t } !function (e) { e.ok = function (e) { return new z(e) }, e.err = function (e) { return new _(e || new Error) }, e.all = function (t) { if (Array.isArray(t)) { for (var n = [], r = 0; r < t.length; r++) { var o = t[r]; if (o.isErr) return o; n.push(o.value) } return e.ok(n) } for (var s = {}, i = Object.keys(t), a = 0; a < i.length; a++) { var c = t[i[a]]; if (c.isErr) return c; s[i[a]] = c.value } return e.ok(s) } }(B || (B = {})); const G = Y((e => X(e, [-9, -8, -7, -1, 1, 7, 8, 9]))), Z = Y((e => X(e, [-17, -15, -10, -6, 6, 10, 15, 17]))), J = { white: Y((e => X(e, [7, 9]))), black: Y((e => X(e, [-7, -9]))) }; function ee(e) { return G[e] } function te(e) { return Z[e] } function ne(e, t) { return J[e][t] } const re = Y((e => T.fromFile(Q(e)).without(e))), oe = Y((e => T.fromRank(H(e)).without(e))), se = Y((e => { const t = new T(134480385, 2151686160), n = 8 * (H(e) - Q(e)); return (n >= 0 ? t.shl64(n) : t.shr64(-n)).without(e) })), ie = Y((e => { const t = new T(270549120, 16909320), n = 8 * (H(e) + Q(e) - 7); return (n >= 0 ? t.shl64(n) : t.shr64(-n)).without(e) })); function ae(e, t, n) { let r = n.intersect(t), o = r.bswap64(); return r = r.minus64(e), o = o.minus64(e.bswap64()), r.xor(o.bswap64()).intersect(t) } function ce(e, t) { const n = T.fromSquare(e); return ae(n, se[e], t).xor(ae(n, ie[e], t)) } function ue(e, t) { return function (e, t) { return ae(T.fromSquare(e), re[e], t) }(e, t).xor(function (e, t) { const n = oe[e]; let r = t.intersect(n), o = r.rbit64(); return r = r.minus64(T.fromSquare(e)), o = o.minus64(T.fromSquare(63 - e)), r.xor(o.rbit64()).intersect(n) }(e, t)) } function he(e, t) { return ce(e, t).xor(ue(e, t)) } function le(e, t) { const n = T.fromSquare(t); return oe[e].intersects(n) ? oe[e].with(e) : ie[e].intersects(n) ? ie[e].with(e) : se[e].intersects(n) ? se[e].with(e) : re[e].intersects(n) ? re[e].with(e) : T.empty() } function de(e, t) { return le(e, t).intersect(T.full().shl64(e).xor(T.full().shl64(t))).withoutFirst() } var pe; !function (e) { e.Empty = "ERR_EMPTY", e.OppositeCheck = "ERR_OPPOSITE_CHECK", e.ImpossibleCheck = "ERR_IMPOSSIBLE_CHECK", e.PawnsOnBackrank = "ERR_PAWNS_ON_BACKRANK", e.Kings = "ERR_KINGS", e.Variant = "ERR_VARIANT" }(pe || (pe = {})); class fe extends Error { } function me(e, t) { return "white" === e ? "a" === t ? 3 : 5 : "a" === t ? 59 : 61 } class ge { constructor() { } static default() { const e = new ge; return e.unmovedRooks = T.corners(), e.rook = { white: { a: 0, h: 7 }, black: { a: 56, h: 63 } }, e.path = { white: { a: new T(14, 0), h: new T(96, 0) }, black: { a: new T(0, 234881024), h: new T(0, 1610612736) } }, e } static empty() { const e = new ge; return e.unmovedRooks = T.empty(), e.rook = { white: { a: void 0, h: void 0 }, black: { a: void 0, h: void 0 } }, e.path = { white: { a: T.empty(), h: T.empty() }, black: { a: T.empty(), h: T.empty() } }, e } clone() { const e = new ge; return e.unmovedRooks = this.unmovedRooks, e.rook = { white: { a: this.rook.white.a, h: this.rook.white.h }, black: { a: this.rook.black.a, h: this.rook.black.h } }, e.path = { white: { a: this.path.white.a, h: this.path.white.h }, black: { a: this.path.black.a, h: this.path.black.h } }, e } add(e, t, n, r) { const o = U(e, t), s = me(e, t); this.unmovedRooks = this.unmovedRooks.with(r), this.rook[e][t] = r, this.path[e][t] = de(r, s).with(s).union(de(n, o).with(o)).without(n).without(r) } static fromSetup(e) { const t = ge.empty(), n = e.unmovedRooks.intersect(e.board.rook); for (const r of q) { const o = T.backrank(r), s = e.board.kingOf(r); if (!V(s) || !o.has(s)) continue; const i = n.intersect(e.board[r]).intersect(o), a = i.first(); V(a) && a < s && t.add(r, "a", s, a); const c = i.last(); V(c) && s < c && t.add(r, "h", s, c) } return t } discardRook(e) { if (this.unmovedRooks.has(e)) { this.unmovedRooks = this.unmovedRooks.without(e); for (const t of q) for (const n of M) this.rook[t][n] === e && (this.rook[t][n] = void 0) } } discardSide(e) { this.unmovedRooks = this.unmovedRooks.diff(T.backrank(e)), this.rook[e].a = void 0, this.rook[e].h = void 0 } } class be extends class { constructor(e) { this.rules = e } kingAttackers(e, t, n) { return function (e, t, n, r) { return n[t].intersect(ue(e, r).intersect(n.rooksAndQueens()).union(ce(e, r).intersect(n.bishopsAndQueens())).union(te(e).intersect(n.knight)).union(ee(e).intersect(n.king)).union(ne(j(t), e).intersect(n.pawn))) }(e, t, this.board, n) } dropDests(e) { return T.empty() } playCaptureAt(e, t) { this.halfmoves = 0, "rook" === t.role && this.castles.discardRook(e), this.pockets && this.pockets[j(t.color)][t.role]++ } ctx() { const e = this.isVariantEnd(), t = this.board.kingOf(this.turn); if (!V(t)) return { king: t, blockers: T.empty(), checkers: T.empty(), variantEnd: e, mustCapture: !1 }; const n = ue(t, T.empty()).intersect(this.board.rooksAndQueens()).union(ce(t, T.empty()).intersect(this.board.bishopsAndQueens())).intersect(this.board[j(this.turn)]); let r = T.empty(); for (const o of n) { const e = de(t, o).intersect(this.board.occupied); e.moreThanOne() || (r = r.union(e)) } return { king: t, blockers: r, checkers: this.kingAttackers(t, j(this.turn), this.board.occupied), variantEnd: e, mustCapture: !1 } } clone() { var e, t; const n = new this.constructor; return n.board = this.board.clone(), n.pockets = null === (e = this.pockets) || void 0 === e ? void 0 : e.clone(), n.turn = this.turn, n.castles = this.castles.clone(), n.epSquare = this.epSquare, n.remainingChecks = null === (t = this.remainingChecks) || void 0 === t ? void 0 : t.clone(), n.halfmoves = this.halfmoves, n.fullmoves = this.fullmoves, n } equalsIgnoreMoves(e) { var t, n; return this.rules === e.rules && (this.pockets ? this.board.equals(e.board) : this.board.equalsIgnorePromoted(e.board)) && (e.pockets && (null === (t = this.pockets) || void 0 === t ? void 0 : t.equals(e.pockets)) || !this.pockets && !e.pockets) && this.turn === e.turn && this.castles.unmovedRooks.equals(e.castles.unmovedRooks) && this.legalEpSquare() === e.legalEpSquare() && (e.remainingChecks && (null === (n = this.remainingChecks) || void 0 === n ? void 0 : n.equals(e.remainingChecks)) || !this.remainingChecks && !e.remainingChecks) } toSetup() { var e, t; return { board: this.board.clone(), pockets: null === (e = this.pockets) || void 0 === e ? void 0 : e.clone(), turn: this.turn, unmovedRooks: this.castles.unmovedRooks, epSquare: this.legalEpSquare(), remainingChecks: null === (t = this.remainingChecks) || void 0 === t ? void 0 : t.clone(), halfmoves: Math.min(this.halfmoves, 150), fullmoves: Math.min(Math.max(this.fullmoves, 1), 9999) } } isInsufficientMaterial() { return q.every((e => this.hasInsufficientMaterial(e))) } hasDests(e) { e = e || this.ctx(); for (const t of this.board[this.turn]) if (this.dests(t, e).nonEmpty()) return !0; return this.dropDests(e).nonEmpty() } isLegal(e, t) { if (P(e)) return !(!this.pockets || this.pockets[this.turn][e.role] <= 0) && (("pawn" !== e.role || !T.backranks().has(e.to)) && this.dropDests(t).has(e.to)); { if ("pawn" === e.promotion) return !1; if ("king" === e.promotion && "antichess" !== this.rules) return !1; if (!!e.promotion !== (this.board.pawn.has(e.from) && T.backranks().has(e.to))) return !1; const n = this.dests(e.from, t); return n.has(e.to) || n.has(this.normalizeMove(e).to) } } isCheck() { const e = this.board.kingOf(this.turn); return V(e) && this.kingAttackers(e, j(this.turn), this.board.occupied).nonEmpty() } isEnd(e) { return !!(e ? e.variantEnd : this.isVariantEnd()) || (this.isInsufficientMaterial() || !this.hasDests(e)) } isCheckmate(e) { return !(e = e || this.ctx()).variantEnd && e.checkers.nonEmpty() && !this.hasDests(e) } isStalemate(e) { return !(e = e || this.ctx()).variantEnd && e.checkers.isEmpty() && !this.hasDests(e) } outcome(e) { const t = this.variantOutcome(e); return t || (e = e || this.ctx(), this.isCheckmate(e) ? { winner: j(this.turn) } : this.isInsufficientMaterial() || this.isStalemate(e) ? { winner: void 0 } : void 0) } allDests(e) { e = e || this.ctx(); const t = new Map; if (e.variantEnd) return t; for (const n of this.board[this.turn]) t.set(n, this.dests(n, e)); return t } castlingSide(e) { if (P(e)) return; const t = e.to - e.from; return (2 === Math.abs(t) || this.board[this.turn].has(e.to)) && this.board.king.has(e.from) ? t > 0 ? "h" : "a" : void 0 } normalizeMove(e) { const t = this.castlingSide(e); if (!t) return e; const n = this.castles.rook[this.turn][t]; return { from: e.from, to: V(n) ? n : e.to } } play(e) { const t = this.turn, n = this.epSquare, r = this.castlingSide(e); if (this.epSquare = void 0, this.halfmoves += 1, "black" === t && (this.fullmoves += 1), this.turn = j(t), P(e)) this.board.set(e.to, { role: e.role, color: t }), this.pockets && this.pockets[t][e.role]--, "pawn" === e.role && (this.halfmoves = 0); else { const o = this.board.take(e.from); if (!o) return; let s; if ("pawn" === o.role) { this.halfmoves = 0, e.to === n && (s = this.board.take(e.to + ("white" === t ? -8 : 8))); const r = e.from - e.to; 16 === Math.abs(r) && 8 <= e.from && e.from <= 55 && (this.epSquare = e.from + e.to >> 1), e.promotion && (o.role = e.promotion, o.promoted = !0) } else if ("rook" === o.role) this.castles.discardRook(e.from); else if ("king" === o.role) { if (r) { const e = this.castles.rook[t][r]; if (V(e)) { const n = this.board.take(e); this.board.set(U(t, r), o), n && this.board.set(me(t, r), n) } } this.castles.discardSide(t) } if (!r) { const t = this.board.set(e.to, o) || s; t && this.playCaptureAt(e.to, t) } } this.remainingChecks && this.isCheck() && (this.remainingChecks[t] = Math.max(this.remainingChecks[t] - 1, 0)) } legalEpSquare(e) { if (!V(this.epSquare)) return; e = e || this.ctx(); const t = this.board.pieces(this.turn, "pawn").intersect(ne(j(this.turn), this.epSquare)); for (const n of t) if (this.dests(n, e).has(this.epSquare)) return this.epSquare } }{ constructor(e) { super(e || "chess") } static default() { const e = new this; return e.board = K.default(), e.pockets = void 0, e.turn = "white", e.castles = ge.default(), e.epSquare = void 0, e.remainingChecks = void 0, e.halfmoves = 0, e.fullmoves = 1, e } static fromSetup(e) { const t = new this; return t.board = e.board.clone(), t.pockets = void 0, t.turn = e.turn, t.castles = ge.fromSetup(e), t.epSquare = t.validEpSquare(e.epSquare), t.remainingChecks = void 0, t.halfmoves = e.halfmoves, t.fullmoves = e.fullmoves, t.validate().map((e => t)) } clone() { return super.clone() } validate() { if (this.board.occupied.isEmpty()) return B.err(new fe(pe.Empty)); if (2 !== this.board.king.size()) return B.err(new fe(pe.Kings)); if (!V(this.board.kingOf(this.turn))) return B.err(new fe(pe.Kings)); const e = this.board.kingOf(j(this.turn)); return V(e) ? this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty() ? B.err(new fe(pe.OppositeCheck)) : T.backranks().intersects(this.board.pawn) ? B.err(new fe(pe.PawnsOnBackrank)) : this.validateCheckers() : B.err(new fe(pe.Kings)) } validateCheckers() { const e = this.board.kingOf(this.turn); if (V(e)) { const t = this.kingAttackers(e, j(this.turn), this.board.occupied); if (t.size() > 2 || 2 === t.size() && le(t.first(), t.last()).has(e)) return B.err(new fe(pe.ImpossibleCheck)); if (V(this.epSquare)) for (const n of t) if (le(n, this.epSquare).has(e)) return B.err(new fe(pe.ImpossibleCheck)) } return B.ok(void 0) } validEpSquare(e) { if (!V(e)) return; const t = "white" === this.turn ? 5 : 2, n = "white" === this.turn ? 8 : -8; if (H(e) !== t) return; if (this.board.occupied.has(e + n)) return; const r = e - n; return this.board.pawn.has(r) && this.board[j(this.turn)].has(r) ? e : void 0 } castlingDest(e, t) { if (!V(t.king) || t.checkers.nonEmpty()) return T.empty(); const n = this.castles.rook[this.turn][e]; if (!V(n)) return T.empty(); if (this.castles.path[this.turn][e].intersects(this.board.occupied)) return T.empty(); const r = U(this.turn, e), o = de(t.king, r), s = this.board.occupied.without(t.king); for (const c of o) if (this.kingAttackers(c, j(this.turn), s).nonEmpty()) return T.empty(); const i = me(this.turn, e), a = this.board.occupied.toggle(t.king).toggle(n).toggle(i); return this.kingAttackers(r, j(this.turn), a).nonEmpty() ? T.empty() : T.fromSquare(n) } canCaptureEp(e, t) { if (!V(this.epSquare)) return !1; if (!ne(this.turn, e).has(this.epSquare)) return !1; if (!V(t.king)) return !0; const n = this.epSquare + ("white" === this.turn ? -8 : 8), r = this.board.occupied.toggle(e).toggle(this.epSquare).toggle(n); return !this.kingAttackers(t.king, j(this.turn), r).intersects(r) } pseudoDests(e, t) { if (t.variantEnd) return T.empty(); const n = this.board.get(e); if (!n || n.color !== this.turn) return T.empty(); let r = function (e, t, n) { switch (e.role) { case "pawn": return ne(e.color, t); case "knight": return te(t); case "bishop": return ce(t, n); case "rook": return ue(t, n); case "queen": return he(t, n); case "king": return ee(t) } }(n, e, this.board.occupied); if ("pawn" === n.role) { let t = this.board[j(this.turn)]; V(this.epSquare) && (t = t.with(this.epSquare)), r = r.intersect(t); const n = "white" === this.turn ? 8 : -8, o = e + n; if (0 <= o && o < 64 && !this.board.occupied.has(o)) { r = r.with(o); const t = o + n; ("white" === this.turn ? e < 16 : e >= 48) && !this.board.occupied.has(t) && (r = r.with(t)) } return r } return r = r.diff(this.board[this.turn]), e === t.king ? r.union(this.castlingDest("a", t)).union(this.castlingDest("h", t)) : r } dests(e, t) { if ((t = t || this.ctx()).variantEnd) return T.empty(); const n = this.board.get(e); if (!n || n.color !== this.turn) return T.empty(); let r, o; if ("pawn" === n.role) { r = ne(this.turn, e).intersect(this.board[j(this.turn)]); const n = "white" === this.turn ? 8 : -8, s = e + n; if (0 <= s && s < 64 && !this.board.occupied.has(s)) { r = r.with(s); const t = s + n; ("white" === this.turn ? e < 16 : e >= 48) && !this.board.occupied.has(t) && (r = r.with(t)) } if (V(this.epSquare) && this.canCaptureEp(e, t)) { const e = this.epSquare - n; (t.checkers.isEmpty() || t.checkers.singleSquare() === e) && (o = T.fromSquare(this.epSquare)) } } else r = "bishop" === n.role ? ce(e, this.board.occupied) : "knight" === n.role ? te(e) : "rook" === n.role ? ue(e, this.board.occupied) : "queen" === n.role ? he(e, this.board.occupied) : ee(e); if (r = r.diff(this.board[this.turn]), V(t.king)) { if ("king" === n.role) { const n = this.board.occupied.without(e); for (const e of r) this.kingAttackers(e, j(this.turn), n).nonEmpty() && (r = r.without(e)); return r.union(this.castlingDest("a", t)).union(this.castlingDest("h", t)) } if (t.checkers.nonEmpty()) { const e = t.checkers.singleSquare(); if (!V(e)) return T.empty(); r = r.intersect(de(e, t.king).with(e)) } t.blockers.has(e) && (r = r.intersect(le(e, t.king))) } return o && (r = r.union(o)), r } isVariantEnd() { return !1 } variantOutcome(e) { } hasInsufficientMaterial(e) { if (this.board[e].intersect(this.board.pawn.union(this.board.rooksAndQueens())).nonEmpty()) return !1; if (this.board[e].intersects(this.board.knight)) return this.board[e].size() <= 2 && this.board[j(e)].diff(this.board.king).diff(this.board.queen).isEmpty(); if (this.board[e].intersects(this.board.bishop)) { return (!this.board.bishop.intersects(T.darkSquares()) || !this.board.bishop.intersects(T.lightSquares())) && this.board.pawn.isEmpty() && this.board.knight.isEmpty() } return !0 } } class ve extends be { constructor() { super("crazyhouse") } static default() { const e = super.default(); return e.pockets = N.empty(), e } static fromSetup(e) { return super.fromSetup(e).map((t => (t.pockets = e.pockets ? e.pockets.clone() : N.empty(), t))) } validate() { return super.validate().chain((e => this.pockets && (this.pockets.white.king > 0 || this.pockets.black.king > 0) ? B.err(new fe(pe.Kings)) : (this.pockets ? this.pockets.count() : 0) + this.board.occupied.size() > 64 ? B.err(new fe(pe.Variant)) : B.ok(void 0))) } clone() { return super.clone() } hasInsufficientMaterial(e) { return this.pockets ? this.board.occupied.size() + this.pockets.count() <= 3 && this.board.pawn.isEmpty() && this.board.promoted.isEmpty() && this.board.rooksAndQueens().isEmpty() && this.pockets.white.pawn <= 0 && this.pockets.black.pawn <= 0 && this.pockets.white.rook <= 0 && this.pockets.black.rook <= 0 && this.pockets.white.queen <= 0 && this.pockets.black.queen <= 0 : super.hasInsufficientMaterial(e) } dropDests(e) { var t, n; const r = this.board.occupied.complement().intersect((null === (t = this.pockets) || void 0 === t ? void 0 : t[this.turn].hasNonPawns()) ? T.full() : (null === (n = this.pockets) || void 0 === n ? void 0 : n[this.turn].hasPawns()) ? T.backranks().complement() : T.empty()); if (V((e = e || this.ctx()).king) && e.checkers.nonEmpty()) { const t = e.checkers.singleSquare(); return V(t) ? r.intersect(de(t, e.king)) : T.empty() } return r } } class ke extends be { constructor() { super("atomic") } static default() { return super.default() } static fromSetup(e) { return super.fromSetup(e) } clone() { return super.clone() } validate() { if (this.board.occupied.isEmpty()) return B.err(new fe(pe.Empty)); if (this.board.king.size() > 2) return B.err(new fe(pe.Kings)); const e = this.board.kingOf(j(this.turn)); return V(e) ? this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty() ? B.err(new fe(pe.OppositeCheck)) : T.backranks().intersects(this.board.pawn) ? B.err(new fe(pe.PawnsOnBackrank)) : B.ok(void 0) : B.err(new fe(pe.Kings)) } kingAttackers(e, t, n) { const r = this.board.pieces(t, "king"); return r.isEmpty() || ee(e).intersects(r) ? T.empty() : super.kingAttackers(e, t, n) } playCaptureAt(e, t) { super.playCaptureAt(e, t), this.board.take(e); for (const n of ee(e).intersect(this.board.occupied).diff(this.board.pawn)) { const e = this.board.take(n); e && "rook" === e.role && this.castles.discardRook(n), e && "king" === e.role && this.castles.discardSide(e.color) } } hasInsufficientMaterial(e) { if (this.board.pieces(j(e), "king").isEmpty()) return !1; if (this.board[e].diff(this.board.king).isEmpty()) return !0; if (this.board[j(e)].diff(this.board.king).nonEmpty()) { if (this.board.occupied.equals(this.board.bishop.union(this.board.king))) { if (!this.board.bishop.intersect(this.board.white).intersects(T.darkSquares())) return !this.board.bishop.intersect(this.board.black).intersects(T.lightSquares()); if (!this.board.bishop.intersect(this.board.white).intersects(T.lightSquares())) return !this.board.bishop.intersect(this.board.black).intersects(T.darkSquares()) } return !1 } return !this.board.queen.nonEmpty() && !this.board.pawn.nonEmpty() && (!!this.board.knight.union(this.board.bishop).union(this.board.rook).isSingleSquare() || !!this.board.occupied.equals(this.board.knight.union(this.board.king)) && this.board.knight.size() <= 2) } dests(e, t) { t = t || this.ctx(); let n = T.empty(); for (const r of this.pseudoDests(e, t)) { const t = this.clone(); t.play({ from: e, to: r }); const o = t.board.kingOf(this.turn); !V(o) || V(t.board.kingOf(t.turn)) && !t.kingAttackers(o, t.turn, t.board.occupied).isEmpty() || (n = n.with(r)) } return n } isVariantEnd() { return !!this.variantOutcome() } variantOutcome(e) { for (const t of q) if (this.board.pieces(t, "king").isEmpty()) return { winner: j(t) } } } class we extends be { constructor() { super("antichess") } static default() { const e = super.default(); return e.castles = ge.empty(), e } static fromSetup(e) { return super.fromSetup(e).map((e => (e.castles = ge.empty(), e))) } clone() { return super.clone() } validate() { return this.board.occupied.isEmpty() ? B.err(new fe(pe.Empty)) : T.backranks().intersects(this.board.pawn) ? B.err(new fe(pe.PawnsOnBackrank)) : B.ok(void 0) } kingAttackers(e, t, n) { return T.empty() } ctx() { const e = super.ctx(), t = this.board[j(this.turn)]; for (const n of this.board[this.turn]) if (this.pseudoDests(n, e).intersects(t)) { e.mustCapture = !0; break } return e } dests(e, t) { t = t || this.ctx(); const n = this.pseudoDests(e, t); return t.mustCapture ? n.intersect(this.board[j(this.turn)]) : n } hasInsufficientMaterial(e) { if (this.board.occupied.equals(this.board.bishop)) { const t = this.board[e].intersects(T.lightSquares()), n = this.board[e].intersects(T.darkSquares()), r = this.board[j(e)].isDisjoint(T.lightSquares()), o = this.board[j(e)].isDisjoint(T.darkSquares()); return t && r || n && o } return !1 } isVariantEnd() { return this.board[this.turn].isEmpty() } variantOutcome(e) { if ((e = e || this.ctx()).variantEnd || this.isStalemate(e)) return { winner: this.turn } } } class ye extends be { constructor() { super("kingofthehill") } static default() { return super.default() } static fromSetup(e) { return super.fromSetup(e) } clone() { return super.clone() } hasInsufficientMaterial(e) { return !1 } isVariantEnd() { return this.board.king.intersects(T.center()) } variantOutcome(e) { for (const t of q) if (this.board.pieces(t, "king").intersects(T.center())) return { winner: t } } } class Ce extends be { constructor() { super("3check") } static default() { const e = super.default(); return e.remainingChecks = I.default(), e } static fromSetup(e) { return super.fromSetup(e).map((t => (t.remainingChecks = e.remainingChecks ? e.remainingChecks.clone() : I.default(), t))) } clone() { return super.clone() } hasInsufficientMaterial(e) { return this.board.pieces(e, "king").equals(this.board[e]) } isVariantEnd() { return !!this.remainingChecks && (this.remainingChecks.white <= 0 || this.remainingChecks.black <= 0) } variantOutcome(e) { if (this.remainingChecks) for (const t of q) if (this.remainingChecks[t] <= 0) return { winner: t } } } class Se extends be { constructor() { super("racingkings") } static default() { const e = new this; return e.board = K.racingKings(), e.pockets = void 0, e.turn = "white", e.castles = ge.empty(), e.epSquare = void 0, e.remainingChecks = void 0, e.halfmoves = 0, e.fullmoves = 1, e } static fromSetup(e) { return super.fromSetup(e).map((e => (e.castles = ge.empty(), e))) } validate() { return this.isCheck() ? B.err(new fe(pe.ImpossibleCheck)) : this.board.pawn.nonEmpty() ? B.err(new fe(pe.Variant)) : super.validate() } clone() { return super.clone() } dests(e, t) { if (e === (t = t || this.ctx()).king) return super.dests(e, t); let n = T.empty(); for (const r of super.dests(e, t)) { const t = { from: e, to: r }, o = this.clone(); o.play(t), o.isCheck() || (n = n.with(r)) } return n } hasInsufficientMaterial(e) { return !1 } isVariantEnd() { const e = T.fromRank(7), t = this.board.king.intersect(e); if (t.isEmpty()) return !1; if ("white" === this.turn || t.intersects(this.board.black)) return !0; const n = this.board.kingOf("black"); if (V(n)) { const t = this.board.occupied.without(n); for (const r of ee(n).intersect(e).diff(this.board.black)) if (this.kingAttackers(r, "white", t).isEmpty()) return !1 } return !0 } variantOutcome(e) { if (e ? !e.variantEnd : !this.isVariantEnd()) return; const t = T.fromRank(7), n = this.board.pieces("black", "king").intersects(t), r = this.board.pieces("white", "king").intersects(t); return n && !r ? { winner: "black" } : r && !n ? { winner: "white" } : { winner: void 0 } } } class Ee extends be { constructor() { super("horde") } static default() { const e = new this; return e.board = K.horde(), e.pockets = void 0, e.turn = "white", e.castles = ge.default(), e.castles.discardSide("white"), e.epSquare = void 0, e.remainingChecks = void 0, e.halfmoves = 0, e.fullmoves = 1, e } static fromSetup(e) { return super.fromSetup(e) } validate() { if (this.board.occupied.isEmpty()) return B.err(new fe(pe.Empty)); if (!this.board.king.isSingleSquare()) return B.err(new fe(pe.Kings)); if (!this.board.king.diff(this.board.promoted).isSingleSquare()) return B.err(new fe(pe.Kings)); const e = this.board.kingOf(j(this.turn)); if (V(e) && this.kingAttackers(e, this.turn, this.board.occupied).nonEmpty()) return B.err(new fe(pe.OppositeCheck)); for (const t of q) if (this.board.pieces(t, "pawn").intersects(T.backrank(j(t)))) return B.err(new fe(pe.PawnsOnBackrank)); return this.validateCheckers() } clone() { return super.clone() } hasInsufficientMaterial(e) { return !1 } isVariantEnd() { return this.board.white.isEmpty() || this.board.black.isEmpty() } variantOutcome(e) { return this.board.white.isEmpty() ? { winner: "black" } : this.board.black.isEmpty() ? { winner: "white" } : void 0 } } function qe(e, t) { switch (e) { case "chess": return be.fromSetup(t); case "antichess": return we.fromSetup(t); case "atomic": return ke.fromSetup(t); case "horde": return Ee.fromSetup(t); case "racingkings": return Se.fromSetup(t); case "kingofthehill": return ye.fromSetup(t); case "3check": return Ce.fromSetup(t); case "crazyhouse": return ve.fromSetup(t) } } const xe = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq -", Me = xe + " 0 1", Pe = "8/8/8/8/8/8/8/8 w - - 0 1"; var Ae; !function (e) { e.Fen = "ERR_FEN", e.Board = "ERR_BOARD", e.Pockets = "ERR_POCKETS", e.Turn = "ERR_TURN", e.Castling = "ERR_CASTLING", e.EpSquare = "ERR_EP_SQUARE", e.RemainingChecks = "ERR_REMAINING_CHECKS", e.Halfmoves = "ERR_HALFMOVES", e.Fullmoves = "ERR_FULLMOVES" }(Ae || (Ae = {})); class Re extends Error { } function Oe(e) { return /^\d{1,4}$/.test(e) ? parseInt(e, 10) : void 0 } function Te(e) { const t = function (e) { switch (e) { case "P": case "p": return "pawn"; case "N": case "n": return "knight"; case "B": case "b": return "bishop"; case "R": case "r": return "rook"; case "Q": case "q": return "queen"; case "K": case "k": return "king"; default: return } }(e); return t && { role: t, color: e.toLowerCase() === e ? "black" : "white" } } function Ke(e) { const t = K.empty(); let n = 7, r = 0; for (let o = 0; o < e.length; o++) { const s = e[o]; if ("/" === s && 8 === r) r = 0, n--; else { const i = parseInt(s, 10); if (i > 0) r += i; else { if (r >= 8 || n < 0) return B.err(new Re(Ae.Board)); const i = r + 8 * n, a = Te(s); if (!a) return B.err(new Re(Ae.Board)); "~" === e[o + 1] && (a.promoted = !0, o++), t.set(i, a), r++ } } } return 0 !== n || 8 !== r ? B.err(new Re(Ae.Board)) : B.ok(t) } function Fe(e) { if (e.length > 64) return B.err(new Re(Ae.Pockets)); const t = N.empty(); for (const n of e) { const e = Te(n); if (!e) return B.err(new Re(Ae.Pockets)); t[e.color][e.role]++ } return B.ok(t) } function Ne(e, t) { let n = T.empty(); if ("-" === t) return B.ok(n); if (!/^[KQABCDEFGH]{0,2}[kqabcdefgh]{0,2}$/.test(t)) return B.err(new Re(Ae.Castling)); for (const r of t) { const t = r.toLowerCase(), o = r === t ? "black" : "white", s = T.backrank(o).intersect(e[o]); let i; i = "q" === t ? s : "k" === t ? s.reversed() : T.fromSquare(t.charCodeAt(0) - "a".charCodeAt(0)).intersect(s); for (const r of i) { if (e.king.has(r) && !e.promoted.has(r)) break; if (e.rook.has(r)) { n = n.with(r); break } } } return B.ok(n) } function Ie(e) { const t = e.split("+"); if (3 === t.length && "" === t[0]) { const e = Oe(t[1]), n = Oe(t[2]); return !V(e) || e > 3 || !V(n) || n > 3 ? B.err(new Re(Ae.RemainingChecks)) : B.ok(new I(3 - e, 3 - n)) } if (2 === t.length) { const e = Oe(t[0]), n = Oe(t[1]); return !V(e) || e > 3 || !V(n) || n > 3 ? B.err(new Re(Ae.RemainingChecks)) : B.ok(new I(e, n)) } return B.err(new Re(Ae.RemainingChecks)) } function Le(e) { const t = e.split(" "), n = t.shift(); let r, o, s = B.ok(void 0); if (n.endsWith("]")) { const e = n.indexOf("["); if (-1 === e) return B.err(new Re(Ae.Fen)); r = Ke(n.substr(0, e)), s = Fe(n.substr(e + 1, n.length - 1 - e - 1)) } else { const e = function (e, t, n) { let r = e.indexOf(t); for (; n-- > 0 && -1 !== r;)r = e.indexOf(t, r + t.length); return r }(n, "/", 7); -1 === e ? r = Ke(n) : (r = Ke(n.substr(0, e)), s = Fe(n.substr(e + 1))) } const i = t.shift(); if (V(i) && "w" !== i) { if ("b" !== i) return B.err(new Re(Ae.Turn)); o = "black" } else o = "white"; return r.chain((e => { const n = t.shift(), r = V(n) ? Ne(e, n) : B.ok(T.empty()), i = t.shift(); let a; if (V(i) && "-" !== i && (a = function (e) { if (2 !== e.length) return; const t = e.charCodeAt(0) - "a".charCodeAt(0), n = e.charCodeAt(1) - "1".charCodeAt(0); return t < 0 || t >= 8 || n < 0 || n >= 8 ? void 0 : t + 8 * n }(i), !V(a))) return B.err(new Re(Ae.EpSquare)); let c, u = t.shift(); V(u) && u.includes("+") && (c = Ie(u), u = t.shift()); const h = V(u) ? Oe(u) : 0; if (!V(h)) return B.err(new Re(Ae.Halfmoves)); const l = t.shift(), d = V(l) ? Oe(l) : 1; if (!V(d)) return B.err(new Re(Ae.Fullmoves)); const p = t.shift(); let f = B.ok(void 0); if (V(p)) { if (V(c)) return B.err(new Re(Ae.RemainingChecks)); f = Ie(p) } else V(c) && (f = c); return t.length > 0 ? B.err(new Re(Ae.Fen)) : s.chain((t => r.chain((n => f.map((r => ({ board: e, pockets: t, turn: o, unmovedRooks: n, remainingChecks: r, epSquare: a, halfmoves: h, fullmoves: Math.max(1, d) }))))))) })) } function Be(e, t) { let n = W(e.role); return "white" === e.color && (n = n.toUpperCase()), (null == t ? void 0 : t.promoted) && e.promoted && (n += "~"), n } function De(e, t) { let n = "", r = 0; for (let o = 7; o >= 0; o--)for (let s = 0; s < 8; s++) { const i = s + 8 * o, a = e.get(i); a ? (r > 0 && (n += r, r = 0), n += Be(a, t)) : r++, 7 === s && (r > 0 && (n += r, r = 0), 0 !== o && (n += "/")) } return n } function ze(e) { return x.map((t => W(t).repeat(e[t]))).join("") } function _e(e, t, n) { const r = null == n ? void 0 : n.shredder; let o = ""; for (const s of q) { const n = T.backrank(s), i = e.kingOf(s); if (!V(i) || !n.has(i)) continue; const a = e.pieces(s, "rook").intersect(n); for (const e of t.intersect(a).reversed()) if (!r && e === a.first() && e < i) o += "white" === s ? "Q" : "q"; else if (!r && e === a.last() && i < e) o += "white" === s ? "K" : "k"; else { const t = S[Q(e)]; o += "white" === s ? t.toUpperCase() : t } } return o || "-" } function Ve(e, t) { return [De(e.board, t) + (e.pockets ? `[${o = e.pockets, ze(o.white).toUpperCase() + ze(o.black)}]` : ""), e.turn[0], _e(e.board, e.unmovedRooks, t), V(e.epSquare) ? (r = e.epSquare, S[Q(r)] + E[H(r)]) : "-", ...e.remainingChecks ? [(n = e.remainingChecks, `${n.white}+${n.black}`)] : [], ...(null == t ? void 0 : t.epd) ? [] : [Math.max(0, Math.min(e.halfmoves, 9999)), Math.max(1, Math.min(e.fullmoves, 9999))]].join(" "); var n, r, o } function $e(e) { switch (e) { case "chess": return "standard"; case "3check": return "threeCheck"; case "kingofthehill": return "kingOfTheHill"; case "racingkings": return "racingKings"; default: return e } } const je = e => void 0 !== e; class He { constructor(e, t) { this.cfg = e, this.options = e.options || {}, this.trans = lichess.trans(this.cfg.i18n), this.selected = (e => { let t = e; return function (e) { return je(e) && (t = e), t } })("pointer"), this.extraPositions = [{ fen: Me, epd: xe, name: this.trans("startPosition") }, { fen: "prompt", name: this.trans("loadPosition") }], e.positions && e.positions.forEach((e => e.epd = e.fen.split(" ").splice(0, 4).join(" "))), e.endgamePositions && e.endgamePositions.forEach((e => e.epd = e.fen.split(" ").splice(0, 4).join(" "))), window.Mousetrap.bind("f", (() => { this.chessground && this.chessground.toggleOrientation(), t() })), this.castlingToggles = { K: !1, Q: !1, k: !1, q: !1 }; const n = new URLSearchParams(location.search); this.rules = "chess", this.initialFen = (e.fen || n.get("fen") || Me).replace(/_/g, " "), this.redraw = () => { }, this.setFen(this.initialFen), this.redraw = t } onChange() { var e, t; const n = this.getFen(); if (!this.cfg.embed) { const e = new URLSearchParams; n === Me && "chess" === this.rules || e.set("fen", n), "chess" !== this.rules && e.set("variant", $e(this.rules)); const t = e.toString(); window.history.replaceState(null, "", "/analysis" + (t ? "?" + t : "")) } null === (t = (e = this.options).onChange) || void 0 === t || t.call(e, n), this.redraw() } castlingToggleFen() { let e = ""; for (const t of C) this.castlingToggles[t] && (e += t); return e } getSetup() { var e; const t = Le((null === (e = this.chessground) || void 0 === e ? void 0 : e.getFen()) || this.initialFen).unwrap((e => e.board), (e => K.empty())); return { board: t, pockets: this.pockets, turn: this.turn, unmovedRooks: this.unmovedRooks || Ne(t, this.castlingToggleFen()).unwrap(), epSquare: this.epSquare, remainingChecks: this.remainingChecks, halfmoves: this.halfmoves, fullmoves: this.fullmoves } } getFen() { return Ve(this.getSetup(), { promoted: "crazyhouse" == this.rules }) } getTurn() { return this.turn } getLegalFen() { return qe(this.rules, this.getSetup()).unwrap((e => Ve(e.toSetup(), { promoted: "crazyhouse" == e.rules })), (e => { })) } isPlayable() { return qe(this.rules, this.getSetup()).unwrap((e => !e.isEnd()), (e => !1)) } getState() { return { fen: this.getFen(), legalFen: this.getLegalFen(), playable: "chess" == this.rules && this.isPlayable() } } makeAnalysisUrl(e) { const t = "chess" === this.rules ? "" : $e(this.rules) + "/"; return this.makeUrl(`/analysis/${t}`, e) } makeUrl(e, t) { return e + encodeURIComponent(t).replace(/%20/g, "_").replace(/%2F/g, "/") } bottomColor() { return this.chessground ? this.chessground.state.orientation : this.options.orientation || "white" } setCastlingToggle(e, t) { this.castlingToggles[e] != t && (this.unmovedRooks = void 0), this.castlingToggles[e] = t, this.onChange() } setTurn(e) { this.turn = e, this.onChange() } startPosition() { this.setFen(Me) } clearBoard() { this.setFen(Pe) } loadNewFen(e) { ("prompt" !== e || (e = (prompt("Paste FEN position") || "").trim())) && this.setFen(e) } setFen(e) { return Le(e).unwrap((t => { this.chessground && this.chessground.set({ fen: e }), this.pockets = t.pockets, this.turn = t.turn, this.unmovedRooks = t.unmovedRooks, this.epSquare = t.epSquare, this.remainingChecks = t.remainingChecks, this.halfmoves = t.halfmoves, this.fullmoves = t.fullmoves; const n = ge.fromSetup(t); return this.castlingToggles.K = je(n.rook.white.h), this.castlingToggles.Q = je(n.rook.white.a), this.castlingToggles.k = je(n.rook.black.h), this.castlingToggles.q = je(n.rook.black.a), this.onChange(), !0 }), (e => !1)) } setRules(e) { this.rules = e, "crazyhouse" != e ? this.pockets = void 0 : this.pockets || (this.pockets = N.empty()), "3check" != e ? this.remainingChecks = void 0 : this.remainingChecks || (this.remainingChecks = I.default()), this.onChange() } setOrientation(e) { this.options.orientation = e, this.chessground.state.orientation !== e && this.chessground.toggleOrientation(), this.redraw() } } const Qe = ["white", "black"], We = ["a", "b", "c", "d", "e", "f", "g", "h"], Ue = ["1", "2", "3", "4", "5", "6", "7", "8"], Xe = [...Ue].reverse(), Ye = Array.prototype.concat(...We.map((e => Ue.map((t => e + t))))), Ge = e => Ye[8 * e[0] + e[1]], Ze = e => [e.charCodeAt(0) - 97, e.charCodeAt(1) - 49], Je = Ye.map(Ze); const et = () => { let e; return { start() { e = performance.now() }, cancel() { e = void 0 }, stop() { if (!e) return 0; const t = performance.now() - e; return e = void 0, t } } }, tt = e => "white" === e ? "black" : "white", nt = (e, t) => { const n = e[0] - t[0], r = e[1] - t[1]; return n * n + r * r }, rt = (e, t) => e.role === t.role && e.color === t.color, ot = e => (t, n) => [(n ? t[0] : 7 - t[0]) * e.width / 8, (n ? 7 - t[1] : t[1]) * e.height / 8], st = (e, t) => { e.style.transform = `translate(${t[0]}px,${t[1]}px)` }, it = (e, t) => { e.style.visibility = t ? "visible" : "hidden" }, at = e => { var t; return e.clientX || 0 === e.clientX ? [e.clientX, e.clientY] : (null === (t = e.targetTouches) || void 0 === t ? void 0 : t[0]) ? [e.targetTouches[0].clientX, e.targetTouches[0].clientY] : void 0 }, ct = e => 2 === e.buttons || 2 === e.button, ut = (e, t) => { const n = document.createElement(e); return t && (n.className = t), n }; function ht(e, t, n) { const r = Ze(e); return t || (r[0] = 7 - r[0], r[1] = 7 - r[1]), [n.left + n.width * r[0] / 8 + n.width / 16, n.top + n.height * (7 - r[1]) / 8 + n.height / 16] } function lt(e, t) { return Math.abs(e - t) } const dt = (e, t, n, r) => { const o = lt(e, n), s = lt(t, r); return 1 === o && 2 === s || 2 === o && 1 === s }, pt = (e, t, n, r) => lt(e, n) === lt(t, r), ft = (e, t, n, r) => e === n || t === r, mt = (e, t, n, r) => pt(e, t, n, r) || ft(e, t, n, r); function gt(e, t, n) { const r = e.get(t); if (!r) return []; const o = Ze(t), s = r.role, i = "pawn" === s ? (a = r.color, (e, t, n, r) => lt(e, n) < 2 && ("white" === a ? r === t + 1 || t <= 1 && r === t + 2 && e === n : r === t - 1 || t >= 6 && r === t - 2 && e === n)) : "knight" === s ? dt : "bishop" === s ? pt : "rook" === s ? ft : "queen" === s ? mt : function (e, t, n) { return (r, o, s, i) => lt(r, s) < 2 && lt(o, i) < 2 || n && o === i && o === ("white" === e ? 0 : 7) && (4 === r && (2 === s && t.includes(0) || 6 === s && t.includes(7)) || t.includes(s)) }(r.color, function (e, t) { const n = "white" === t ? "1" : "8", r = []; for (const [o, s] of e) o[1] === n && s.color === t && "rook" === s.role && r.push(Ze(o)[0]); return r }(e, r.color), n); var a; return Je.filter((e => (o[0] !== e[0] || o[1] !== e[1]) && i(o[0], o[1], e[0], e[1]))).map(Ge) } function bt(e, ...t) { e && setTimeout((() => e(...t)), 1) } function vt(e) { e.premovable.current && (e.premovable.current = void 0, bt(e.premovable.events.unset)) } function kt(e) { const t = e.predroppable; t.current && (t.current = void 0, bt(t.events.unset)) } function wt(e, t, n) { const r = e.pieces.get(t), o = e.pieces.get(n); if (t === n || !r) return !1; const s = o && o.color !== r.color ? o : void 0; return n === e.selected && Mt(e), bt(e.events.move, t, n, s), function (e, t, n) { if (!e.autoCastle) return !1; const r = e.pieces.get(t); if (!r || "king" !== r.role) return !1; const o = Ze(t), s = Ze(n); if (0 !== o[1] && 7 !== o[1] || o[1] !== s[1]) return !1; 4 !== o[0] || e.pieces.has(n) || (6 === s[0] ? n = Ge([7, s[1]]) : 2 === s[0] && (n = Ge([0, s[1]]))); const i = e.pieces.get(n); return !(!i || i.color !== r.color || "rook" !== i.role || (e.pieces.delete(t), e.pieces.delete(n), o[0] < s[0] ? (e.pieces.set(Ge([6, s[1]]), r), e.pieces.set(Ge([5, s[1]]), i)) : (e.pieces.set(Ge([2, s[1]]), r), e.pieces.set(Ge([3, s[1]]), i)), 0)) }(e, t, n) || (e.pieces.set(n, r), e.pieces.delete(t)), e.lastMove = [t, n], e.check = void 0, bt(e.events.change), s || !0 } function yt(e, t, n, r) { if (e.pieces.has(n)) { if (!r) return !1; e.pieces.delete(n) } return bt(e.events.dropNewPiece, t, n), e.pieces.set(n, t), e.lastMove = [n], e.check = void 0, bt(e.events.change), e.movable.dests = void 0, e.turnColor = tt(e.turnColor), !0 } function Ct(e, t, n) { const r = wt(e, t, n); return r && (e.movable.dests = void 0, e.turnColor = tt(e.turnColor), e.animation.current = void 0), r } function St(e, t, n) { if (At(e, t, n)) { const r = Ct(e, t, n); if (r) { const o = e.hold.stop(); Mt(e); const s = { premove: !1, ctrlKey: e.stats.ctrlKey, holdTime: o }; return !0 !== r && (s.captured = r), bt(e.movable.events.after, t, n, s), !0 } } else if (function (e, t, n) { return t !== n && Rt(e, t) && gt(e.pieces, t, e.premovable.castle).includes(n) }(e, t, n)) return function (e, t, n, r) { kt(e), e.premovable.current = [t, n], bt(e.premovable.events.set, t, n, r) }(e, t, n, { ctrlKey: e.stats.ctrlKey }), Mt(e), !0; return Mt(e), !1 } function Et(e, t, n, r) { const o = e.pieces.get(t); o && (function (e, t, n) { const r = e.pieces.get(t); return !(!r || t !== n && e.pieces.has(n) || "both" !== e.movable.color && (e.movable.color !== r.color || e.turnColor !== r.color)) }(e, t, n) || r) ? (e.pieces.delete(t), yt(e, o, n, r), bt(e.movable.events.afterNewPiece, o.role, n, { premove: !1, predrop: !1 })) : o && function (e, t, n) { const r = e.pieces.get(t), o = e.pieces.get(n); return !!r && (!o || o.color !== e.movable.color) && e.predroppable.enabled && ("pawn" !== r.role || "1" !== n[1] && "8" !== n[1]) && e.movable.color === r.color && e.turnColor !== r.color }(e, t, n) ? function (e, t, n) { vt(e), e.predroppable.current = { role: t, key: n }, bt(e.predroppable.events.set, t, n) }(e, o.role, n) : (vt(e), kt(e)), e.pieces.delete(t), Mt(e) } function qt(e, t, n) { if (bt(e.events.select, t), e.selected) { if (e.selected === t && !e.draggable.enabled) return Mt(e), void e.hold.cancel(); if ((e.selectable.enabled || n) && e.selected !== t && St(e, e.selected, t)) return void (e.stats.dragged = !1) } (Pt(e, t) || Rt(e, t)) && (xt(e, t), e.hold.start()) } function xt(e, t) { e.selected = t, Rt(e, t) ? e.premovable.dests = gt(e.pieces, t, e.premovable.castle) : e.premovable.dests = void 0 } function Mt(e) { e.selected = void 0, e.premovable.dests = void 0, e.hold.cancel() } function Pt(e, t) { const n = e.pieces.get(t); return !!n && ("both" === e.movable.color || e.movable.color === n.color && e.turnColor === n.color) } function At(e, t, n) { var r, o; return t !== n && Pt(e, t) && (e.movable.free || !!(null === (o = null === (r = e.movable.dests) || void 0 === r ? void 0 : r.get(t)) || void 0 === o ? void 0 : o.includes(n))) } function Rt(e, t) { const n = e.pieces.get(t); return !!n && e.premovable.enabled && e.movable.color === n.color && e.turnColor !== n.color } function Ot(e) { const t = e.premovable.current; if (!t) return !1; const n = t[0], r = t[1]; let o = !1; if (At(e, n, r)) { const t = Ct(e, n, r); if (t) { const s = { premove: !0 }; !0 !== t && (s.captured = t), bt(e.movable.events.after, n, r, s), o = !0 } } return vt(e), o } function Tt(e) { vt(e), kt(e), Mt(e) } function Kt(e) { e.movable.color = e.movable.dests = e.animation.current = void 0, Tt(e) } function Ft(e, t, n) { let r = Math.floor(8 * (e[0] - n.left) / n.width); t || (r = 7 - r); let o = 7 - Math.floor(8 * (e[1] - n.top) / n.height); return t || (o = 7 - o), r >= 0 && r < 8 && o >= 0 && o < 8 ? Ge([r, o]) : void 0 } function Nt(e) { return "white" === e.orientation } const It = ["green", "red", "blue", "yellow"]; function Lt(e, t) { if (t.touches && t.touches.length > 1) return; t.stopPropagation(), t.preventDefault(), t.ctrlKey ? Mt(e) : Tt(e); const n = at(t), r = Ft(n, Nt(e), e.dom.bounds()); r && (e.drawable.current = { orig: r, pos: n, brush: Vt(t), snapToValidMove: e.drawable.defaultSnapToValidMove }, Bt(e)) } function Bt(e) { requestAnimationFrame((() => { const t = e.drawable.current; if (t) { const n = Ft(t.pos, Nt(e), e.dom.bounds()); n || (t.snapToValidMove = !1); const r = t.snapToValidMove ? function (e, t, n, r) { const o = Ze(e), s = Je.filter((e => mt(o[0], o[1], e[0], e[1]) || dt(o[0], o[1], e[0], e[1]))), i = s.map((e => ht(Ge(e), n, r))).map((e => nt(t, e))), [, a] = i.reduce(((e, t, n) => e[0] < t ? e : [t, n]), [i[0], 0]); return Ge(s[a]) }(t.orig, t.pos, Nt(e), e.dom.bounds()) : n; r !== t.mouseSq && (t.mouseSq = r, t.dest = r !== t.orig ? r : void 0, e.dom.redrawNow()), Bt(e) } })) } function Dt(e, t) { e.drawable.current && (e.drawable.current.pos = at(t)) } function zt(e) { const t = e.drawable.current; t && (t.mouseSq && function (e, t) { const n = e => e.orig === t.orig && e.dest === t.dest, r = e.shapes.find(n); r && (e.shapes = e.shapes.filter((e => !n(e)))); r && r.brush === t.brush || e.shapes.push(t); $t(e) }(e.drawable, t), _t(e)) } function _t(e) { e.drawable.current && (e.drawable.current = void 0, e.dom.redraw()) } function Vt(e) { var t; const n = (e.shiftKey || e.ctrlKey) && ct(e), r = e.altKey || e.metaKey || (null === (t = e.getModifierState) || void 0 === t ? void 0 : t.call(e, "AltGraph")); return It[(n ? 1 : 0) + (r ? 2 : 0)] } function $t(e) { e.onChange && e.onChange(e.shapes) } function jt(e, t) { return t.animation.enabled ? function (e, t) { const n = new Map(t.pieces), r = e(t), o = function (e, t) { const n = new Map, r = [], o = new Map, s = [], i = [], a = new Map; let c, u, h; for (const [l, d] of e) a.set(l, Qt(l, d)); for (const l of Ye) c = t.pieces.get(l), u = a.get(l), c ? u ? rt(c, u.piece) || (s.push(u), i.push(Qt(l, c))) : i.push(Qt(l, c)) : u && s.push(u); for (const l of i) u = Wt(l, s.filter((e => rt(l.piece, e.piece)))), u && (h = [u.pos[0] - l.pos[0], u.pos[1] - l.pos[1]], n.set(l.key, h.concat(h)), r.push(u.key)); for (const l of s) r.includes(l.key) || o.set(l.key, l.piece); return { anims: n, fadings: o } }(n, t); if (o.anims.size || o.fadings.size) { const e = t.animation.current && t.animation.current.start; t.animation.current = { start: performance.now(), frequency: 1 / t.animation.duration, plan: o }, e || Ut(t, performance.now()) } else t.dom.redraw(); return r }(e, t) : Ht(e, t) } function Ht(e, t) { const n = e(t); return t.dom.redraw(), n } function Qt(e, t) { return { key: e, pos: Ze(e), piece: t } } function Wt(e, t) { return t.sort(((t, n) => nt(e.pos, t.pos) - nt(e.pos, n.pos)))[0] } function Ut(e, t) { const n = e.animation.current; if (void 0 === n) return void (e.dom.destroyed || e.dom.redrawNow()); const r = 1 - (t - n.start) * n.frequency; if (r <= 0) e.animation.current = void 0, e.dom.redrawNow(); else { const t = function (e) { return e < .5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1 }(r); for (const e of n.plan.anims.values()) e[2] = e[0] * t, e[3] = e[1] * t; e.dom.redrawNow(!0), requestAnimationFrame(((t = performance.now()) => Ut(e, t))) } } function Xt(e, t) { if (!t.isTrusted || void 0 !== t.button && 0 !== t.button) return; if (t.touches && t.touches.length > 1) return; const n = e.dom.bounds(), r = at(t), o = Ft(r, Nt(e), n); if (!o) return; const s = e.pieces.get(o), i = e.selected; var a; i || !e.drawable.enabled || !e.drawable.eraseOnClick && s && s.color === e.turnColor || (a = e).drawable.shapes.length && (a.drawable.shapes = [], a.dom.redraw(), $t(a.drawable)), !1 !== t.cancelable && (!t.touches || e.blockTouchScroll || s || i || function (e, t) { const n = Nt(e), r = e.dom.bounds(), o = Math.pow(r.width / 8, 2); for (const s of e.pieces.keys()) { const e = ht(s, n, r); if (nt(e, t) <= o) return !0 } return !1 }(e, r)) && t.preventDefault(); const c = !!e.premovable.current, u = !!e.predroppable.current; e.stats.ctrlKey = t.ctrlKey, e.selected && At(e, e.selected, o) ? jt((e => qt(e, o)), e) : qt(e, o); const h = e.selected === o, l = nn(e, o); if (s && l && h && function (e, t) { const n = e.pieces.get(t); return !!n && e.draggable.enabled && ("both" === e.movable.color || e.movable.color === n.color && (e.turnColor === n.color || e.premovable.enabled)) }(e, o)) { e.draggable.current = { orig: o, piece: s, origPos: r, pos: r, started: e.draggable.autoDistance && e.stats.dragged, element: l, previouslySelected: i, originTarget: t.target, keyHasChanged: !1 }, l.cgDragging = !0, l.classList.add("dragging"); const a = e.dom.elements.ghost; a && (a.className = `ghost ${s.color} ${s.role}`, st(a, ot(n)(Ze(o), Nt(e))), it(a, !0)), Gt(e) } else c && vt(e), u && kt(e); e.dom.redraw() } function Yt(e, t, n, r) { const o = "a0"; e.pieces.set(o, t), e.dom.redraw(); const s = at(n); e.draggable.current = { orig: o, piece: t, origPos: s, pos: s, started: !0, element: () => nn(e, o), originTarget: n.target, newPiece: !0, force: !!r, keyHasChanged: !1 }, Gt(e) } function Gt(e) { requestAnimationFrame((() => { var t; const n = e.draggable.current; if (!n) return; (null === (t = e.animation.current) || void 0 === t ? void 0 : t.plan.anims.has(n.orig)) && (e.animation.current = void 0); const r = e.pieces.get(n.orig); if (r && rt(r, n.piece)) { if (!n.started && nt(n.pos, n.origPos) >= Math.pow(e.draggable.distance, 2) && (n.started = !0), n.started) { if ("function" == typeof n.element) { const e = n.element(); if (!e) return; e.cgDragging = !0, e.classList.add("dragging"), n.element = e } const t = e.dom.bounds(); st(n.element, [n.pos[0] - t.left - t.width / 16, n.pos[1] - t.top - t.height / 16]), n.keyHasChanged || (n.keyHasChanged = n.orig !== Ft(n.pos, Nt(e), t)) } } else en(e); Gt(e) })) } function Zt(e, t) { e.draggable.current && (!t.touches || t.touches.length < 2) && (e.draggable.current.pos = at(t)) } function Jt(e, t) { const n = e.draggable.current; if (!n) return; if ("touchend" === t.type && !1 !== t.cancelable && t.preventDefault(), "touchend" === t.type && n.originTarget !== t.target && !n.newPiece) return void (e.draggable.current = void 0); vt(e), kt(e); const r = Ft(at(t) || n.pos, Nt(e), e.dom.bounds()); r && n.started && n.orig !== r ? n.newPiece ? Et(e, n.orig, r, n.force) : (e.stats.ctrlKey = t.ctrlKey, St(e, n.orig, r) && (e.stats.dragged = !0)) : n.newPiece ? e.pieces.delete(n.orig) : e.draggable.deleteOnDropOff && !r && (e.pieces.delete(n.orig), bt(e.events.change)), (n.orig !== n.previouslySelected && !n.keyHasChanged || n.orig !== r && r) && e.selectable.enabled || Mt(e), tn(e), e.draggable.current = void 0, e.dom.redraw() } function en(e) { const t = e.draggable.current; t && (t.newPiece && e.pieces.delete(t.orig), e.draggable.current = void 0, Mt(e), tn(e), e.dom.redraw()) } function tn(e) { const t = e.dom.elements; t.ghost && it(t.ghost, !1) } function nn(e, t) { let n = e.dom.elements.board.firstChild; for (; n;) { if (n.cgKey === t && "PIECE" === n.tagName) return n; n = n.nextSibling } } const rn = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR", on = { p: "pawn", r: "rook", n: "knight", b: "bishop", q: "queen", k: "king" }, sn = { pawn: "p", rook: "r", knight: "n", bishop: "b", queen: "q", king: "k" }; function an(e) { "start" === e && (e = rn); const t = new Map; let n = 7, r = 0; for (const o of e) switch (o) { case " ": return t; case "/": if (--n, n < 0) return t; r = 0; break; case "~": { const e = t.get(Ge([r, n])); e && (e.promoted = !0); break } default: { const e = o.charCodeAt(0); if (e < 57) r += e - 48; else { const e = o.toLowerCase(); t.set(Ge([r, n]), { role: on[e], color: o === e ? "black" : "white" }), ++r } } }return t } function cn(e, t) { t.animation && (hn(e.animation, t.animation), (e.animation.duration || 0) < 70 && (e.animation.enabled = !1)) } function un(e, t) { var n, r; if ((null === (n = t.movable) || void 0 === n ? void 0 : n.dests) && (e.movable.dests = void 0), (null === (r = t.drawable) || void 0 === r ? void 0 : r.autoShapes) && (e.drawable.autoShapes = []), hn(e, t), t.fen && (e.pieces = an(t.fen), e.drawable.shapes = []), "check" in t && function (e, t) { if (e.check = void 0, !0 === t && (t = e.turnColor), t) for (const [n, r] of e.pieces) "king" === r.role && r.color === t && (e.check = n) }(e, t.check || !1), "lastMove" in t && !t.lastMove ? e.lastMove = void 0 : t.lastMove && (e.lastMove = t.lastMove), e.selected && xt(e, e.selected), cn(e, t), !e.movable.rookCastle && e.movable.dests) { const t = "white" === e.movable.color ? "1" : "8", n = "e" + t, r = e.movable.dests.get(n), o = e.pieces.get(n); if (!r || !o || "king" !== o.role) return; e.movable.dests.set(n, r.filter((e => !(e === "a" + t && r.includes("c" + t) || e === "h" + t && r.includes("g" + t))))) } } function hn(e, t) { for (const n in t) ln(e[n]) && ln(t[n]) ? hn(e[n], t[n]) : e[n] = t[n] } function ln(e) { return "object" == typeof e } function dn(e, t) { e.exploding && (t ? e.exploding.stage = t : e.exploding = void 0, e.dom.redraw()) } function pn(e, t) { function n() { !function (e) { e.orientation = tt(e.orientation), e.animation.current = e.draggable.current = e.selected = void 0 }(e), t() } return { set(t) { t.orientation && t.orientation !== e.orientation && n(), cn(e, t), (t.fen ? jt : Ht)((e => un(e, t)), e) }, state: e, getFen: () => { return t = e.pieces, Xe.map((e => We.map((n => { const r = t.get(n + e); if (r) { const e = sn[r.role]; return "white" === r.color ? e.toUpperCase() : e } return "1" })).join(""))).join("/").replace(/1{2,}/g, (e => e.length.toString())); var t }, toggleOrientation: n, setPieces(t) { jt((e => function (e, t) { for (const [n, r] of t) r ? e.pieces.set(n, r) : e.pieces.delete(n) }(e, t)), e) }, selectSquare(t, n) { t ? jt((e => qt(e, t, n)), e) : e.selected && (Mt(e), e.dom.redraw()) }, move(t, n) { jt((e => wt(e, t, n)), e) }, newPiece(t, n) { jt((e => yt(e, t, n)), e) }, playPremove() { if (e.premovable.current) { if (jt(Ot, e)) return !0; e.dom.redraw() } return !1 }, playPredrop(t) { if (e.predroppable.current) { const n = function (e, t) { const n = e.predroppable.current; let r = !1; if (!n) return !1; t(n) && yt(e, { role: n.role, color: e.movable.color }, n.key) && (bt(e.movable.events.afterNewPiece, n.role, n.key, { premove: !1, predrop: !0 }), r = !0); return kt(e), r }(e, t); return e.dom.redraw(), n } return !1 }, cancelPremove() { Ht(vt, e) }, cancelPredrop() { Ht(kt, e) }, cancelMove() { Ht((e => { Tt(e), en(e) }), e) }, stop() { Ht((e => { Kt(e), en(e) }), e) }, explode(t) { !function (e, t) { e.exploding = { stage: 1, keys: t }, e.dom.redraw(), setTimeout((() => { dn(e, 2), setTimeout((() => dn(e, void 0)), 120) }), 120) }(e, t) }, setAutoShapes(t) { Ht((e => e.drawable.autoShapes = t), e) }, setShapes(t) { Ht((e => e.drawable.shapes = t), e) }, getKeyAtDomPos: t => Ft(t, Nt(e), e.dom.bounds()), redrawAll: t, dragNewPiece(t, n, r) { Yt(e, t, n, r) }, destroy() { Kt(e), e.dom.unbind && e.dom.unbind(), e.dom.destroyed = !0 } } } function fn(e) { return document.createElementNS("http://www.w3.org/2000/svg", e) } function mn(e, t, n) { const r = e.drawable, o = r.current, s = o && o.mouseSq ? o : void 0, i = new Map, a = e.dom.bounds(); for (const p of r.shapes.concat(r.autoShapes).concat(s ? [s] : [])) p.dest && i.set(p.dest, (i.get(p.dest) || 0) + 1); const c = r.shapes.concat(r.autoShapes).map((e => ({ shape: e, current: !1, hash: bn(e, i, !1, a) }))); s && c.push({ shape: s, current: !0, hash: bn(s, i, !0, a) }); const u = c.map((e => e.hash)).join(";"); if (u === e.drawable.prevSvgHash) return; e.drawable.prevSvgHash = u; const h = t.querySelector("defs"), l = t.querySelector("g"), d = n.querySelector("g"); !function (e, t, n) { const r = new Map; let o; for (const a of t) a.shape.dest && (o = e.brushes[a.shape.brush], a.shape.modifiers && (o = En(o, a.shape.modifiers)), r.set(o.key, o)); const s = new Set; let i = n.firstChild; for (; i;)s.add(i.getAttribute("cgKey")), i = i.nextSibling; for (const [a, c] of r.entries()) s.has(a) || n.appendChild(yn(c)) }(r, c, h), gn(e, c.filter((e => !e.shape.customSvg)), r.brushes, i, l), gn(e, c.filter((e => e.shape.customSvg)), r.brushes, i, d) } function gn(e, t, n, r, o) { const s = e.dom.bounds(), i = new Map, a = []; for (const h of t) i.set(h.hash, !1); let c, u = o.firstChild; for (; u;)c = u.getAttribute("cgHash"), i.has(c) ? i.set(c, !0) : a.push(u), u = u.nextSibling; for (const h of a) o.removeChild(h); for (const h of t) i.get(h.hash) || o.appendChild(wn(e, h, n, r, s)) } function bn({ orig: e, dest: t, brush: n, piece: r, modifiers: o, customSvg: s }, i, a, c) { return [c.width, c.height, a, e, t, n, t && (i.get(t) || 0) > 1, r && vn(r), o && (u = o, "" + (u.lineWidth || "")), s && kn(s)].filter((e => e)).join(","); var u } function vn(e) { return [e.color, e.role, e.scale].filter((e => e)).join(",") } function kn(e) { let t = 0; for (let n = 0; n < e.length; n++)t = (t << 5) - t + e.charCodeAt(n) >>> 0; return "custom-" + t.toString() } function wn(e, { shape: t, current: n, hash: r }, o, s, i) { let a; if (t.customSvg) { const n = Sn(Ze(t.orig), e.orientation); a = function (e, t, n) { const [r, o] = Mn(t, n), s = Cn(fn("g"), { transform: `translate(${r},${o})` }), i = Cn(fn("svg"), { width: 1, height: 1, viewBox: "0 0 100 100" }); return s.appendChild(i), i.innerHTML = e, s }(t.customSvg, n, i) } else if (t.piece) a = function (e, t, n, r) { const o = Mn(t, r), s = n.color[0] + ("knight" === n.role ? "n" : n.role[0]).toUpperCase(); return Cn(fn("image"), { className: `${n.role} ${n.color}`, x: o[0] - .5, y: o[1] - .5, width: 1, height: 1, href: e + s + ".svg", transform: `scale(${n.scale || 1})`, "transform-origin": `${o[0]} ${o[1]}` }) }(e.drawable.pieces.baseUrl, Sn(Ze(t.orig), e.orientation), t.piece, i); else { const r = Sn(Ze(t.orig), e.orientation); if (t.dest) { let c = o[t.brush]; t.modifiers && (c = En(c, t.modifiers)), a = function (e, t, n, r, o, s) { const i = function (e) { return (e ? 20 : 10) / 64 }(o && !r), a = Mn(t, s), c = Mn(n, s), u = c[0] - a[0], h = c[1] - a[1], l = Math.atan2(h, u), d = Math.cos(l) * i, p = Math.sin(l) * i; return Cn(fn("line"), { stroke: e.color, "stroke-width": qn(e, r), "stroke-linecap": "round", "marker-end": "url(#arrowhead-" + e.key + ")", opacity: xn(e, r), x1: a[0], y1: a[1], x2: c[0] - d, y2: c[1] - p }) }(c, r, Sn(Ze(t.dest), e.orientation), n, (s.get(t.dest) || 0) > 1, i) } else a = function (e, t, n, r) { const o = Mn(t, r), s = [3 / 64, 4 / 64], i = (r.width + r.height) / (4 * Math.max(r.width, r.height)); return Cn(fn("circle"), { stroke: e.color, "stroke-width": s[n ? 0 : 1], fill: "none", opacity: xn(e, n), cx: o[0], cy: o[1], r: i - s[1] / 2 }) }(o[t.brush], r, n, i) } return a.setAttribute("cgHash", r), a } function yn(e) { const t = Cn(fn("marker"), { id: "arrowhead-" + e.key, orient: "auto", markerWidth: 4, markerHeight: 8, refX: 2.05, refY: 2.01 }); return t.appendChild(Cn(fn("path"), { d: "M0,0 V4 L3,2 Z", fill: e.color })), t.setAttribute("cgKey", e.key), t } function Cn(e, t) { for (const n in t) e.setAttribute(n, t[n]); return e } function Sn(e, t) { return "white" === t ? e : [7 - e[0], 7 - e[1]] } function En(e, t) { return { color: e.color, opacity: Math.round(10 * e.opacity) / 10, lineWidth: Math.round(t.lineWidth || e.lineWidth), key: [e.key, t.lineWidth].filter((e => e)).join("") } } function qn(e, t) { return (e.lineWidth || 10) * (t ? .85 : 1) / 64 } function xn(e, t) { return (e.opacity || 1) * (t ? .9 : 1) } function Mn(e, t) { const n = Math.min(1, t.width / t.height), r = Math.min(1, t.height / t.width); return [(e[0] - 3.5) * n, (3.5 - e[1]) * r] } function Pn(e, t) { const n = ut("coords", t); let r; for (const o of e) r = ut("coord"), r.textContent = o, n.appendChild(r); return n } function An(e, t) { const n = e.dom.elements.board; if ("ResizeObserver" in window && new ResizeObserver(t).observe(e.dom.elements.wrap), e.viewOnly) return; const r = function (e) { return t => { e.draggable.current ? en(e) : e.drawable.current ? _t(e) : t.shiftKey || ct(t) ? e.drawable.enabled && Lt(e, t) : e.viewOnly || (e.dropmode.active ? function (e, t) { if (!e.dropmode.active) return; vt(e), kt(e); const n = e.dropmode.piece; if (n) { e.pieces.set("a0", n); const r = at(t), o = r && Ft(r, Nt(e), e.dom.bounds()); o && Et(e, "a0", o) } e.dom.redraw() }(e, t) : Xt(e, t)) } }(e); n.addEventListener("touchstart", r, { passive: !1 }), n.addEventListener("mousedown", r, { passive: !1 }), (e.disableContextMenu || e.drawable.enabled) && n.addEventListener("contextmenu", (e => e.preventDefault())) } function Rn(e, t, n, r) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n, r) } function On(e, t, n) { return r => { e.drawable.current ? e.drawable.enabled && n(e, r) : e.viewOnly || t(e, r) } } function Tn(e) { const t = Nt(e), n = ot(e.dom.bounds()), r = e.dom.elements.board, o = e.pieces, s = e.animation.current, i = s ? s.plan.anims : new Map, a = s ? s.plan.fadings : new Map, c = e.draggable.current, u = function (e) { var t; const n = new Map; if (e.lastMove && e.highlight.lastMove) for (const s of e.lastMove) Dn(n, s, "last-move"); e.check && e.highlight.check && Dn(n, e.check, "check"); if (e.selected && (Dn(n, e.selected, "selected"), e.movable.showDests)) { const r = null === (t = e.movable.dests) || void 0 === t ? void 0 : t.get(e.selected); if (r) for (const t of r) Dn(n, t, "move-dest" + (e.pieces.has(t) ? " oc" : "")); const o = e.premovable.dests; if (o) for (const t of o) Dn(n, t, "premove-dest" + (e.pieces.has(t) ? " oc" : "")) } const r = e.premovable.current; if (r) for (const s of r) Dn(n, s, "current-premove"); else e.predroppable.current && Dn(n, e.predroppable.current.key, "current-premove"); const o = e.exploding; if (o) for (const s of o.keys) Dn(n, s, "exploding" + o.stage); return n }(e), h = new Set, l = new Set, d = new Map, p = new Map; let f, m, g, b, v, k, w, y, C, S; for (m = r.firstChild; m;) { if (f = m.cgKey, Fn(m)) if (g = o.get(f), v = i.get(f), k = a.get(f), b = m.cgPiece, !m.cgDragging || c && c.orig === f || (m.classList.remove("dragging"), st(m, n(Ze(f), t)), m.cgDragging = !1), !k && m.cgFading && (m.cgFading = !1, m.classList.remove("fading")), g) { if (v && m.cgAnimating && b === Bn(g)) { const e = Ze(f); e[0] += v[2], e[1] += v[3], m.classList.add("anim"), st(m, n(e, t)) } else m.cgAnimating && (m.cgAnimating = !1, m.classList.remove("anim"), st(m, n(Ze(f), t)), e.addPieceZIndex && (m.style.zIndex = Ln(Ze(f), t))); b !== Bn(g) || k && m.cgFading ? k && b === Bn(k) ? (m.classList.add("fading"), m.cgFading = !0) : zn(d, b, m) : h.add(f) } else zn(d, b, m); else if (Nn(m)) { const e = m.className; u.get(f) === e ? l.add(f) : zn(p, e, m) } m = m.nextSibling } for (const [E, q] of u) if (!l.has(E)) { C = p.get(q), S = C && C.pop(); const e = n(Ze(E), t); if (S) S.cgKey = E, st(S, e); else { const t = ut("square", q); t.cgKey = E, st(t, e), r.insertBefore(t, r.firstChild) } } for (const [E, q] of o) if (v = i.get(E), !h.has(E)) if (w = d.get(Bn(q)), y = w && w.pop(), y) { y.cgKey = E, y.cgFading && (y.classList.remove("fading"), y.cgFading = !1); const r = Ze(E); e.addPieceZIndex && (y.style.zIndex = Ln(r, t)), v && (y.cgAnimating = !0, y.classList.add("anim"), r[0] += v[2], r[1] += v[3]), st(y, n(r, t)) } else { const o = Bn(q), s = ut("piece", o), i = Ze(E); s.cgPiece = o, s.cgKey = E, v && (s.cgAnimating = !0, i[0] += v[2], i[1] += v[3]), st(s, n(i, t)), e.addPieceZIndex && (s.style.zIndex = Ln(i, t)), r.appendChild(s) } for (const E of d.values()) In(e, E); for (const E of p.values()) In(e, E) } function Kn(e) { const t = e.dom.elements.wrap.getBoundingClientRect(), n = e.dom.elements.container, r = t.height / t.width, o = 8 * Math.floor(t.width * window.devicePixelRatio / 8) / window.devicePixelRatio, s = o * r; n.style.width = o + "px", n.style.height = s + "px", e.dom.bounds.clear(), e.addDimensionsCssVars && (document.documentElement.style.setProperty("--cg-width", o + "px"), document.documentElement.style.setProperty("--cg-height", s + "px")) } function Fn(e) { return "PIECE" === e.tagName } function Nn(e) { return "SQUARE" === e.tagName } function In(e, t) { for (const n of t) e.dom.elements.board.removeChild(n) } function Ln(e, t) { let n = 3 + 8 * e[1] + (7 - e[0]); return t && (n = 69 - n), n + "" } function Bn(e) { return `${e.color} ${e.role}` } function Dn(e, t, n) { const r = e.get(t); r ? e.set(t, `${r} ${n}`) : e.set(t, n) } function zn(e, t, n) { const r = e.get(t); r ? r.push(n) : e.set(t, [n]) } function _n(e, t) { const n = { pieces: an(rn), orientation: "white", turnColor: "white", coordinates: !0, autoCastle: !0, viewOnly: !1, disableContextMenu: !1, addPieceZIndex: !1, addDimensionsCssVars: !1, blockTouchScroll: !1, pieceKey: !1, highlight: { lastMove: !0, check: !0 }, animation: { enabled: !0, duration: 200 }, movable: { free: !0, color: "both", showDests: !0, events: {}, rookCastle: !0 }, premovable: { enabled: !0, showDests: !0, castle: !0, events: {} }, predroppable: { enabled: !1, events: {} }, draggable: { enabled: !0, distance: 3, autoDistance: !0, showGhost: !0, deleteOnDropOff: !1 }, dropmode: { active: !1 }, selectable: { enabled: !0 }, stats: { dragged: !("ontouchstart" in window) }, events: {}, drawable: { enabled: !0, visible: !0, defaultSnapToValidMove: !0, eraseOnClick: !0, shapes: [], autoShapes: [], brushes: { green: { key: "g", color: "#15781B", opacity: 1, lineWidth: 10 }, red: { key: "r", color: "#882020", opacity: 1, lineWidth: 10 }, blue: { key: "b", color: "#003088", opacity: 1, lineWidth: 10 }, yellow: { key: "y", color: "#e68f00", opacity: 1, lineWidth: 10 }, paleBlue: { key: "pb", color: "#003088", opacity: .4, lineWidth: 15 }, paleGreen: { key: "pg", color: "#15781B", opacity: .4, lineWidth: 15 }, paleRed: { key: "pr", color: "#882020", opacity: .4, lineWidth: 15 }, paleGrey: { key: "pgr", color: "#4a4a4a", opacity: .35, lineWidth: 15 } }, pieces: { baseUrl: "https://lichess1.org/assets/piece/cburnett/" }, prevSvgHash: "" }, hold: et() }; function r() { const t = "dom" in n ? n.dom.unbind : void 0, r = function (e, t) { e.innerHTML = "", e.classList.add("cg-wrap"); for (const a of Qe) e.classList.toggle("orientation-" + a, t.orientation === a); e.classList.toggle("manipulable", !t.viewOnly); const n = ut("cg-container"); e.appendChild(n); const r = ut("cg-board"); let o, s, i; if (n.appendChild(r), t.drawable.visible && (o = Cn(fn("svg"), { class: "cg-shapes", viewBox: "-4 -4 8 8", preserveAspectRatio: "xMidYMid slice" }), o.appendChild(fn("defs")), o.appendChild(fn("g")), s = Cn(fn("svg"), { class: "cg-custom-svgs", viewBox: "-3.5 -3.5 8 8", preserveAspectRatio: "xMidYMid slice" }), s.appendChild(fn("g")), n.appendChild(o), n.appendChild(s)), t.coordinates) { const e = "black" === t.orientation ? " black" : ""; n.appendChild(Pn(Ue, "ranks" + e)), n.appendChild(Pn(We, "files" + e)) } return t.draggable.showGhost && (i = ut("piece", "ghost"), it(i, !1), n.appendChild(i)), { board: r, container: n, wrap: e, ghost: i, svg: o, customSvg: s } }(e, n), o = function (e) { let t; const n = () => (void 0 === t && (t = e()), t); return n.clear = () => { t = void 0 }, n }((() => r.board.getBoundingClientRect())), s = e => { Tn(a), !e && r.svg && mn(a, r.svg, r.customSvg) }, i = () => { Kn(a), function (e) { const t = Nt(e), n = ot(e.dom.bounds()); let r = e.dom.elements.board.firstChild; for (; r;)(Fn(r) && !r.cgAnimating || Nn(r)) && st(r, n(Ze(r.cgKey), t)), r = r.nextSibling }(a) }, a = n; return a.dom = { elements: r, bounds: o, redraw: Vn(s), redrawNow: s, unbind: t }, a.drawable.prevSvgHash = "", Kn(a), s(!1), An(a, i), t || (a.dom.unbind = function (e, t) { const n = []; if ("ResizeObserver" in window || n.push(Rn(document.body, "chessground.resize", t)), !e.viewOnly) { const t = On(e, Zt, Dt), r = On(e, Jt, zt); for (const e of ["touchmove", "mousemove"]) n.push(Rn(document, e, t)); for (const e of ["touchend", "mouseup"]) n.push(Rn(document, e, r)); const o = () => e.dom.bounds.clear(); n.push(Rn(document, "scroll", o, { capture: !0, passive: !0 })), n.push(Rn(window, "resize", o, { passive: !0 })) } return () => n.forEach((e => e())) }(a, i)), a.events.insert && a.events.insert(r), a } return un(n, t || {}), pn(r(), r) } function Vn(e) { let t = !1; return () => { t || (t = !0, requestAnimationFrame((() => { e(), t = !1 }))) } } function $n(e) { return l("div.cg-wrap", { hook: { insert: t => { const n = t.elm; e.chessground = _n(n, function (e) { return { fen: e.initialFen, orientation: e.options.orientation || "white", coordinates: !e.cfg.embed, autoCastle: !1, addPieceZIndex: e.cfg.is3d, movable: { free: !0, color: "both" }, animation: { duration: e.cfg.animation.duration }, premovable: { enabled: !1 }, drawable: { enabled: !0, defaultSnapToValidMove: "0" != (lichess.storage.get("arrow.snap") || 1) }, draggable: { showGhost: !0, deleteOnDropOff: !0 }, selectable: { enabled: !1 }, highlight: { lastMove: !1 }, events: { change: e.onChange.bind(e) } } }(e)), function (e, t) { const n = function (e) { return function (t) { const n = e.selected(); if ("pointer" === n || !1 === t.cancelable || "touchstart" !== t.type && "touchmove" !== t.type || t.preventDefault(), function (e) { return jn(e) && !e.ctrlKey }(t) || "touchstart" === t.type || "touchmove" === t.type) { if ("pointer" === n || e.chessground && e.chessground.state.draggable.current && e.chessground.state.draggable.current.newPiece) return; const r = at(t); if (!r) return; const o = e.chessground.getKeyAtDomPos(r); if (!o) return; if ("mousedown" !== t.type && "touchstart" !== t.type || (Hn = o), "trash" === n) Xn(e, o, t); else { const r = e.chessground.state.pieces.get(o), s = { color: n[0], role: n[1] }, i = r && s.color == r.color && s.role == r.role; if ("mousedown" !== t.type && "touchstart" !== t.type || !i) Wn || "mousedown" !== t.type && "touchstart" !== t.type && o === Qn || (e.chessground.setPieces(new Map([[o, s]])), e.onChange(), e.chessground.cancelMove()); else { Xn(e, o, t), Wn = !0; const n = { mousedown: "mouseup", touchstart: "touchend" }; document.addEventListener(n[t.type], (() => Wn = !1), { once: !0 }) } } Qn = o } else (function (e) { return ct(e) || !!e.ctrlKey && jn(e) })(t) && "pointer" !== n && (e.chessground.state.drawable.current = void 0, e.chessground.state.drawable.shapes = [], "contextmenu" === t.type && "trash" != n && (e.chessground.cancelMove(), n[0] = tt(n[0]), e.redraw())) } }(t);["touchstart", "touchmove", "mousedown", "mousemove", "contextmenu"].forEach((function (t) { e.addEventListener(t, n) })) }(n, e) }, destroy: t => e.chessground.destroy() } }) } function jn(e) { return 1 === e.buttons || 1 === e.button } let Hn, Qn, Wn, Un; function Xn(e, t, n) { "touchstart" === n.type ? (e.chessground.state.pieces.has(t) && (e.chessground.state.draggable.current.element.style.display = "none", e.chessground.cancelMove()), document.addEventListener("touchend", (() => Yn(e, t)), { once: !0 })) : "mousedown" !== n.type && t === Hn || Yn(e, t) } function Yn(e, t) { e.chessground.setPieces(new Map([[t, void 0]])), e.onChange() } function Gn(e, t, n, r) { const o = l("input", { attrs: { type: "checkbox" }, props: { checked: e.castlingToggles[t] }, on: { change(n) { e.setCastlingToggle(t, n.target.checked) } } }); return l("label", r ? [o, n] : [n, o]) } function Zn(e, t) { return l("optgroup", { attrs: { label: e } }, t) } function Jn(e, t) { const n = function (e) { return l("option", { attrs: { value: e.epd || e.fen, "data-fen": e.fen } }, e.eco ? `${e.eco} ${e.name}` : e.name) }; return l("div.board-editor__tools", [...!e.cfg.embed && e.cfg.positions && e.cfg.endgamePositions ? [l("div", [l("select.positions", { props: { value: t.fen.split(" ").slice(0, 4).join(" ") }, on: { change(t) { const n = t.target; let r = n.selectedOptions[0].getAttribute("data-fen"); "prompt" == r && (r = (prompt("Paste FEN") || "").trim()), r && e.setFen(r) || (n.value = "") } } }, [Zn(e.trans.noarg("setTheBoard"), [l("option", { attrs: { selected: !0 } }, `- ${e.trans.noarg("boardEditor")}  -`), ...e.extraPositions.map(n)]), Zn(e.trans.noarg("popularOpenings"), e.cfg.positions.map(n)), Zn(e.trans.noarg("endgamePositions"), e.cfg.endgamePositions.map((function (e) { return l("option", { attrs: { value: e.epd || e.fen, "data-fen": e.fen } }, e.name) })))])])] : [], l("div.metadata", [l("div.color", l("select", { on: { change(t) { e.setTurn(t.target.value) } }, props: { value: e.turn } }, ["whitePlays", "blackPlays"].map((function (t) { return l("option", { attrs: { value: "w" === t[0] ? "white" : "black", selected: t[0] === e.turn[0] } }, e.trans(t)) })))), l("div.castling", [l("strong", e.trans.noarg("castling")), l("div", [Gn(e, "K", e.trans.noarg("whiteCastlingKingside"), !!e.options.inlineCastling), Gn(e, "Q", "O-O-O", !0)]), l("div", [Gn(e, "k", e.trans.noarg("blackCastlingKingside"), !!e.options.inlineCastling), Gn(e, "q", "O-O-O", !0)])])]), ...e.cfg.embed ? [l("div.actions", [l("a.button.button-empty", { on: { click() { e.startPosition() } } }, e.trans.noarg("startPosition")), l("a.button.button-empty", { on: { click() { e.clearBoard() } } }, e.trans.noarg("clearBoard"))])] : [l("div.actions", [l("button.button.button-empty.text", { attrs: { "data-icon": "" }, on: { click() { e.setFen(Pe) } } }, e.trans.noarg("clearBoard")), l("button.button.button-empty.text", { attrs: { "data-icon": "" }, on: { click() { e.chessground.toggleOrientation(), e.redraw() } } }, e.trans.noarg("flipBoard"))]), l("div.continue-with.none", [l("a.button", { attrs: { href: "/?fen=" + t.legalFen + "#ai", rel: "nofollow" } }, e.trans.noarg("playWithTheMachine")), l("a.button", { attrs: { href: "/?fen=" + t.legalFen + "#friend", rel: "nofollow" } }, e.trans.noarg("playWithAFriend"))])]]) } function er(e, t) { if (!e.cfg.embed) return l("div.copyables", [l("p", [l("strong", "FEN"), l("input.copyable", { attrs: { spellcheck: !1 }, props: { value: t }, on: { change(t) { const n = t.target; e.setFen(n.value.trim()), n.reportValidity() }, input(e) { const t = e.target, n = Le(t.value.trim()).isOk; t.setCustomValidity(n ? "" : "Invalid FEN") }, blur(t) { const n = t.target; n.value = e.getFen(), n.setCustomValidity("") } } })])]) } function tr(e) { return "pointer" === e || "trash" === e ? e : e.join(" ") } function nr(e, t, n, r) { const o = tr(e.selected()), s = ["king", "queen", "rook", "bishop", "knight", "pawn"].map((function (e) { return [t, e] })); return l("div", { attrs: { class: ["spare", "spare-" + r, "spare-" + t].join(" ") } }, ["pointer", ...s, "trash"].map((t => { const n = tr(t), r = Object.assign({ class: n }, "pointer" !== t && "trash" !== t ? { "data-color": t[0], "data-role": t[1] } : {}); return l("div", { class: { "no-square": !0, pointer: "pointer" === t, trash: "trash" === t, "selected-square": !(o !== n || e.chessground && e.chessground.state.draggable.current && e.chessground.state.draggable.current.newPiece) }, on: { mousedown: rr(e, t, "mouseup"), touchstart: rr(e, t, "touchend"), touchmove: e => { Un = at(e) } } }, [l("div", [l("piece", { attrs: r })])]) }))) } function rr(e, t, n) { return function (r) { r.preventDefault(), "pointer" === t || "trash" === t ? (e.selected(t), e.redraw()) : (e.selected("pointer"), Yt(e.chessground.state, { color: t[0], role: t[1] }, r, !0), document.addEventListener(n, (n => { const r = at(n) || Un; r && e.chessground.getKeyAtDomPos(r) ? e.selected("pointer") : e.selected(t), e.redraw() }), { once: !0 })) } } function or(e) { if ("pointer" === e) return "pointer"; const t = "trash" === e ? "trash" : e.join("-"); return `url('${lichess.assetUrl("cursors/" + t + ".cur")}'), default !important` } function sr(e) { const t = e.getState(), n = e.bottomColor(); return l("div.board-editor", { attrs: { style: `cursor: ${or(e.selected())}` } }, [nr(e, tt(n), 0, "top"), l("div.main-board", [$n(e)]), nr(e, n, 0, "bottom"), Jn(e, t), er(e, t.fen)]) } const ir = function (h, l) { const d = { create: [], update: [], remove: [], destroy: [], pre: [], post: [] }, p = void 0 !== l ? l : e; for (const e of u) for (const t of h) { const n = t[e]; void 0 !== n && d[e].push(n) } function f(e) { const n = e.id ? "#" + e.id : "", r = e.getAttribute("class"), o = r ? "." + r.split(" ").join(".") : ""; return t(p.tagName(e).toLowerCase() + n + o, {}, [], void 0, e) } function m(e, t) { return function () { if (0 == --t) { const t = p.parentNode(e); p.removeChild(t, e) } } } function g(e, t) { var a, c; let u, h = e.data; if (void 0 !== h) { const t = null === (a = h.hook) || void 0 === a ? void 0 : a.init; s(t) && (t(e), h = e.data) } const l = e.children, f = e.sel; if ("!" === f) o(e.text) && (e.text = ""), e.elm = p.createComment(e.text); else if (void 0 !== f) { const o = f.indexOf("#"), a = f.indexOf(".", o), m = o > 0 ? o : f.length, b = a > 0 ? a : f.length, v = -1 !== o || -1 !== a ? f.slice(0, Math.min(m, b)) : f, k = e.elm = s(h) && s(u = h.ns) ? p.createElementNS(u, v, h) : p.createElement(v, h); for (m < b && k.setAttribute("id", f.slice(m + 1, b)), a > 0 && k.setAttribute("class", f.slice(b + 1).replace(/\./g, " ")), u = 0; u < d.create.length; ++u)d.create[u](i, e); if (n(l)) for (u = 0; u < l.length; ++u) { const e = l[u]; null != e && p.appendChild(k, g(e, t)) } else r(e.text) && p.appendChild(k, p.createTextNode(e.text)); const w = e.data.hook; s(w) && (null === (c = w.create) || void 0 === c || c.call(w, i, e), w.insert && t.push(e)) } else e.elm = p.createTextNode(e.text); return e.elm } function b(e, t, n, r, o, s) { for (; r <= o; ++r) { const o = n[r]; null != o && p.insertBefore(e, g(o, s), t) } } function v(e) { var t, n; const r = e.data; if (void 0 !== r) { null === (n = null === (t = null == r ? void 0 : r.hook) || void 0 === t ? void 0 : t.destroy) || void 0 === n || n.call(t, e); for (let t = 0; t < d.destroy.length; ++t)d.destroy[t](e); if (void 0 !== e.children) for (let t = 0; t < e.children.length; ++t) { const n = e.children[t]; null != n && "string" != typeof n && v(n) } } } function k(e, t, n, r) { for (var o, i; n <= r; ++n) { let r, a; const c = t[n]; if (null != c) if (s(c.sel)) { v(c), r = d.remove.length + 1, a = m(c.elm, r); for (let t = 0; t < d.remove.length; ++t)d.remove[t](c, a); const e = null === (i = null === (o = null == c ? void 0 : c.data) || void 0 === o ? void 0 : o.hook) || void 0 === i ? void 0 : i.remove; s(e) ? e(c, a) : a() } else p.removeChild(e, c.elm) } } function w(e, t, n) { var r, i, u, h, l; const f = null === (r = t.data) || void 0 === r ? void 0 : r.hook; null === (i = null == f ? void 0 : f.prepatch) || void 0 === i || i.call(f, e, t); const m = t.elm = e.elm, v = e.children, y = t.children; if (e !== t) { if (void 0 !== t.data) { for (let n = 0; n < d.update.length; ++n)d.update[n](e, t); null === (h = null === (u = t.data.hook) || void 0 === u ? void 0 : u.update) || void 0 === h || h.call(u, e, t) } o(t.text) ? s(v) && s(y) ? v !== y && function (e, t, n, r) { let s, i, u, h, l = 0, d = 0, f = t.length - 1, m = t[0], v = t[f], y = n.length - 1, C = n[0], S = n[y]; for (; l <= f && d <= y;)null == m ? m = t[++l] : null == v ? v = t[--f] : null == C ? C = n[++d] : null == S ? S = n[--y] : a(m, C) ? (w(m, C, r), m = t[++l], C = n[++d]) : a(v, S) ? (w(v, S, r), v = t[--f], S = n[--y]) : a(m, S) ? (w(m, S, r), p.insertBefore(e, m.elm, p.nextSibling(v.elm)), m = t[++l], S = n[--y]) : a(v, C) ? (w(v, C, r), p.insertBefore(e, v.elm, m.elm), v = t[--f], C = n[++d]) : (void 0 === s && (s = c(t, l, f)), i = s[C.key], o(i) ? p.insertBefore(e, g(C, r), m.elm) : (u = t[i], u.sel !== C.sel ? p.insertBefore(e, g(C, r), m.elm) : (w(u, C, r), t[i] = void 0, p.insertBefore(e, u.elm, m.elm))), C = n[++d]); (l <= f || d <= y) && (l > f ? (h = null == n[y + 1] ? null : n[y + 1].elm, b(e, h, n, d, y, r)) : k(e, t, l, f)) }(m, v, y, n) : s(y) ? (s(e.text) && p.setTextContent(m, ""), b(m, null, y, 0, y.length - 1, n)) : s(v) ? k(m, v, 0, v.length - 1) : s(e.text) && p.setTextContent(m, "") : e.text !== t.text && (s(v) && k(m, v, 0, v.length - 1), p.setTextContent(m, t.text)), null === (l = null == f ? void 0 : f.postpatch) || void 0 === l || l.call(f, e, t) } } return function (e, t) { let n, r, o; const s = []; for (n = 0; n < d.pre.length; ++n)d.pre[n](); for (function (e) { return void 0 !== e.sel }(e) || (e = f(e)), a(e, t) ? w(e, t, s) : (r = e.elm, o = p.parentNode(r), g(t, s), null !== o && (p.insertBefore(o, t.elm, p.nextSibling(r)), k(o, [e], 0, 0))), n = 0; n < s.length; ++n)s[n].data.hook.insert(s[n]); for (n = 0; n < d.post.length; ++n)d.post[n](); return t } }([m, p, y, k]); return window.Chessground = _n, function (e, t) { const n = new He(t, (function () { o = ir(o, sr(n)) })); e.innerHTML = ""; const r = document.createElement("div"); e.appendChild(r); let o = ir(r, sr(n)); return function () { if ("ontouchstart" in window) return; let e, t; const n = n => { e = n.pageX, t = n.pageY }; let r = {}; $("#topnav.hover").each((function () { const o = $(this).removeClass("hover"), s = () => o.toggleClass("hover"), i = () => { Math.sqrt((r.pX - e) * (r.pX - e) + (r.pY - t) * (r.pY - t)) < 8 ? (o.off(r.event, n), delete r.timeoutId, r.isActive = !0, s()) : (r.pX = e, r.pY = t, r.timeoutId = setTimeout(i, 200)) }, a = function (e) { r.timeoutId && (r.timeoutId = clearTimeout(r.timeoutId)); const t = r.event = "mousemove"; if ("mouseover" == e.type) { if (r.isActive || e.buttons) return; r.pX = e.pageX, r.pY = e.pageY, o.off(t, n).on(t, n), r.timeoutId = setTimeout(i, 200) } else { if (!r.isActive) return; o.off(t, n), r = {}, s() } }; o.on("mouseover", a).on("mouseleave", a) })) }(), { getFen: n.getFen.bind(n), setFen: n.setFen.bind(n), setOrientation: n.setOrientation.bind(n), getTurn: n.getTurn.bind(n), getState: n.getState.bind(n), getOrientation: n.bottomColor.bind(n) } } }();
